\documentclass{article}


% \usepackage{todonotes}
\usepackage{amsmath,amssymb,amsthm}
%\usepackage{unicode-math}
\usepackage{url}
\usepackage{fullpage}

\usepackage{subcaption}
\usepackage{cedilleverbatim}
\usepackage{proof}

\usepackage{stmaryrd}
\usepackage{soul}
% \usepackage{unicode-math}

\DeclareUnicodeCharacter{03BC}{\ensuremath{\mu}}
\DeclareUnicodeCharacter{21A6}{\ensuremath{\mapsto}}
\DeclareUnicodeCharacter{25CF}{\ensuremath{\bullet}}
\DeclareUnicodeCharacter{1D48C}{\ensuremath{\kappa}}

% useful macros
\newcommand{\ann}[2]{#1\! : \! #2}
\newcommand{\abs}[4]{{#1}\, #2\! : \! #3.\, #4}
\newcommand{\absu}[3]{{#1}\, #2.\, #3}
\mathchardef\mhyph="2D % Define a "math hyphen"
\newcommand{\indast}[4]{\texttt{Ind}_{#1} [#2] (#3 := #4)}
\newcommand{\lowerc}[1]{\lfloor {#1} \rfloor}
\newcommand{\lenc}[1]{\|#1\|}
\newcommand{\vars}[1]{{\overline{#1}}}

% - type inference
\newcommand{\decdir}{\vdash_{\delta}}
\newcommand{\decsyn}{\vdash_{\Uparrow}}
\newcommand{\decchk}{\vdash_{\Downarrow}}

% - inductive
\newcommand{\mufix}[3]{Œº\ #1\ .\ #2\ \textbf{\{} #3 \textbf{\}}}
\newcommand{\mumat}[2]{Œº'\ #1\ \textbf{\{}#2\textbf{\}}}
\newcommand{\wfpat}[4]{WF\!\mhyph\!Pat(#1,#2,#3,#4)}
\newcommand{\llbrace}{\{\!\{}
\newcommand{\rrbrace}{\}\!\}}
\newcommand{\piforall}{^{\Pi}_{\forall}}

\begin{document}

\title{The Cedilleum Language Specification \\ \large Syntax, Typing, Reduction,
  and Elaboration }

\author{Christopher Jenkins}

\maketitle

\section{Introduction}
The document describes \textit{Cedilleum}, a general-purpose dependently typed
programming language with inductive datatypes. Unlike most languages of this
description, the underlying theory of Cedilleum is \textit{not} the Calculus of
Inductive Constructions (CIC)\cite{Pa15_Intro-CIC}. Instead, Cedilleum is
designed so that it may easily be translated to \textit{Cedille Core} -- a
compact core theory in which induction is derivable for lambda-encoded datatypes
-- while still providing high-level features like pattern-matching and recursive
definitions. That said, the formal specification of Cedilleum as a
self-contained language has a lot in common with CIC -- see in particular
Section 8 of \cite{In18_Coq-Docs}, which served as the basic template for much
of this document's formal development.

\subsection{Data-type Declarations}
Before diving into the details, let us take a bird's-eye view of the language
by showing some simple example data-type definitions and functions over them.

\begin{figure}[h]
\begin{verbatim}
-- Non-recursive
data Bool: ‚òÖ =
  | tt: Bool
  | ff: Bool
.
-- Recursive
data Nat: ‚òÖ = 
  | zero: Nat
  | succ: Nat ‚ûî Nat
.
-- Recursive, parameterized, indexed
data Vec (A: ‚òÖ): Nat ‚ûî ‚òÖ =
  | vnil : Vec zero
  | vcons: ‚àÄ n: Nat. A ‚ûî Vec n ‚ûî Vec (succ n)
.
\end{verbatim}
  \caption{Definition of natural numbers and length-indexed lists}
  \label{fig:ex-data-decl}
\end{figure}
Figure \ref{fig:ex-data-decl} shows some definitions of inductive datatypes, and
modulo differences in syntax should seem straightforward to programmers that
have used languages like Agda, Idris, or Coq. The key things to note are:

\begin{itemize}
\item In constructor type signatures, recursive occurrences of the inductive
  data-type being defined (such as in \texttt{suc : \underline{Nat} ‚ûî Nat}) must
  be positive, \textit{but not strictly positive}.
\item In parameterized types (like \texttt{Vec} with parameter \texttt{(A: ‚òÖ)})
  occurrences of the inductive type being defined are not written applied to
  its parameters.
  
  For example, the constructor declaration \texttt{vnil : Vec zero} results in
  the term \texttt{vnil} having type \\ \texttt{‚àÄ A: ‚òÖ. Vec ¬∑A zero} (with \texttt{¬∑}
  denoting type application)
\item In the constructor declaration \texttt{vcons : ‚àÄ n: Nat. A ‚ûî Vec n ‚ûî Vec
    (succ n)}, the argument \texttt{n} is \textit{computationally irrelevant}
  (also called \textit{erased}). This is because it is introduced by the
  irrelevant dependent function former \texttt{‚àÄ}, as opposed to the relevant
  function former \texttt{Œ†}. More will be said of this when we discuss the type
  system of Cedilleum, but for now it suffices to say that this idea comes from
  the \textit{Implicit Calculus of Constructions}\cite{Mi01_ICC}
\end{itemize}

\subsection{Function Definitions}
\begin{figure}[h]
\begin{verbatim}
-- Non-recursive
ite : ‚àÄ X: ‚òÖ. Bool ‚ûî X ‚ûî X ‚ûî X
  = Œõ X. Œª b. Œª then. Œª else. Œº' b {
      | tt ‚Ü¶ then
      | ff ‚Ü¶ else
      }.
pred : Nat ‚ûî Nat
  = Œª n. Œº' n {
      | zero    ‚Ü¶ n
      | succ n' ‚Ü¶ n'
      }
-- Recursive
add : Nat ‚ûî Nat ‚ûî Nat
  = Œª n. Œª m.
      Œº add-rec. n @(Œª x: Nat. Nat) {
      | zero   ‚Ü¶ m
      | succ p ‚Ü¶ succ (add-rec p)
      }.
\end{verbatim}
  \caption{Functions over inductive datatypes}
  \label{fig:ex-data-fun}
\end{figure}

Figure \ref{fig:ex-data-fun} shows functions defined over inductive datatypes
using pattern matching and recursion. The first difference to note between the
definitions is that functions \texttt{ite} and \texttt{pred} perform ``mere''
pattern matching on their arguments by using \texttt{Œº'}, whereas \texttt{add}
uses \texttt{Œº} which provides combined pattern-matching and fix-point
recursion. In \texttt{add}, \texttt{Œº} binds \texttt{add-rec} as the name of the
fixpoint function for recursion on \texttt{n}. From this alone the reader might
expect that \texttt{Œº'} is merely syntactic sugar for the more verbose
\texttt{Œº}, just without recursion. Actually the difference is a bit more subtle
that this, as we will see shortly.

The first major departure of Cedilleum from other languages with inductive
datatypes can be seen in the type of \texttt{add-rec}. Ordinarily, its type
would be \verb;Œ† x: Nat. Nat; (corresponding to the motive
\verb;(Œª x: Nat.Nat);) -- but in Cedilleum, its type is \verb;Nat/add-rec ‚ûî Nat;
 (where we read \texttt{Nat/add-rec} as a single identifier) and by extension
for the expression \texttt{add-rec p} to be well-typed, the \texttt{p} bound in
the pattern \texttt{succ p} must have type \texttt{Nat/add-rec} and not the more
usual \texttt{Nat}. The type \texttt{Nat/add-rec} is \textit{automatically
generated} by Cedilleum by combining the name of the inductive datatype
\texttt{Nat} with the of the function \texttt{add-rec} bound by \texttt{Œº}. Why?
For recursive functions in Cedilleum, \textit{termination is guaranteed by the
type system} and not by a separate syntactic check for structurally-decreasing
arguments. The type \texttt{Nat/add-rec} indicates the types of those terms
which the function \texttt{add-rec} may legally take as arguments without
risking non-termination, and within a case branch variables of this type are
introduced in the place of recursive arguments to constructors -- that is,
\texttt{p} in the pattern \texttt{succ p}. In Section \ref{sec:hist-rec}, we
will see more of how to use ``recursive occurence'' types like
\texttt{Nat/add-rec}, including how to do further pattern matching on them and
perform conversion back to the original type. For now it suffices to consider
them an artifice for type-guided termination.
% \footnotetext{More precisely, the type of every
% variable bound by a constructor pattern of a case branch introduced by
% \texttt{Œº} has all occurences of $\texttt{I}\ \vars{P}$ replaced by
% \texttt{I/fixpoint-name}, where $\vars{P}$ are the parameters.}

% The type \texttt{Nat/add-rec} (and any such type generated by use of
% \texttt{Œº}) comes with some restrictions, which will be made more precise
% further on in the document. Informally, such terms cannot themselves be given to
% \texttt{Œº} directly as in `\verb;Œº add-rec2. r; ...' and despite the deceptive
% case label `\verb;| suc r ‚Ü¶ ;...' \texttt{r} cannot be given directly to
% constructor \texttt{succ}, as \texttt{Nat} and \texttt{Nat/add-rec} are distinct
% types. However, even so these two types \textit{are} related to each other, most
% notably in the way they are treated by \texttt{Œº'} -- terms of type \texttt{Nat}
% and \texttt{Nat/add-rec} alike support mere pattern matching through \texttt{Œº'}.

\begin{figure}[h]
\begin{verbatim}
-- Recursive, parameterized, indexed
vappend : ‚àÄ A: ‚òÖ. ‚àÄ m: Nat. ‚àÄ n: Nat. Vec ¬∑A m ‚ûî Vec ¬∑A n ‚ûî Vec ¬∑A (add m n)
  = Œõ A. Œõ m. Œõ n. Œª xs. Œª ys.
      Œº vappend-rec. xs @(Œª i: Nat. Œª zs: Vec ¬∑A i. Vec ¬∑A (add i n)) {
      | vnil            ‚Ü¶ ys
      | vcons -m' x xs' ‚Ü¶ [ zs = vappend-rec -m' xs' ] - vcons -(add m' n) x zs
      }.
\end{verbatim}
  \caption{Dependent functions over inductive datatypes}
  \label{fig:ex-data-dep}
\end{figure}

Figure \ref{fig:ex-data-dep} shows the classic dependent function
\texttt{vappend} over length-indexed lists \texttt{Vec}. Like \texttt{add}, it is
defined by fixpoint recursion, here over the argument \texttt{xs}, and as with
\texttt{add-rec} the fixpoint function \texttt{vappend-rec} has type
\verb;‚àÄ i: Nat. Œ† zs: Vec/vappend-rec i. Vec ¬∑A (add i n);, where the \texttt{‚àÄ}
indicates that \texttt{i} is an \textit{irrelevant} argument. Note again the
missing parameter \texttt{A} in the type \texttt{Vec/vappend-rec i} -- this is
not a typo, but rather an indication that \texttt{A} is ``baked-in'' to the type
\texttt{Vec/vappend-rec}. Aside from this the two cases of \texttt{vappend} are
mostly straightforward: in the \texttt{vnil} branch the expected type is
\verb;Vec ¬∑A (add zero n); which converts to \verb;Vec ¬∑A n;, so \texttt{ys}
suffices; in the \texttt{vcons} branch we bind subdata \verb;m': Nat;,
\verb;x: A;, and \verb;xs': Vec/vappend-rec m';, with \verb;-m'; indicating
that \verb;m'; is bound \textit{irrelevantly}, then we make a local biding
\texttt{zs} by invoking \verb;vappend; recursively on \texttt{m'} and
\texttt{xs'} (where again the \texttt{-m'} indicates \texttt{m'} is an
\textit{irrelevant} argument to \texttt{vappend-rec}) before producing a result whose type is
convertible with the expected \verb;Vec ¬∑A (add (suc m') n);.

\subsection{Histomorphic Recursion}
\label{sec:hist-rec}
\begin{figure}[h]
\begin{verbatim}
iterate : ‚àÄ R: ‚òÖ. Nat ‚ûî (R ‚ûî R) ‚ûî R ‚ûî R
  = Œõ R. Œª n. Œª f. Œª x.
      Œº iterate-rec. n @(Œª _: Nat. Nat) {
      | zero    ‚Ü¶ r
      | succ r' ‚Ü¶ f (iterate-rec r') 
      }.
minus : Nat ‚ûî Nat ‚ûî Nat
  = Œª m. Œª n.
      Œº minus-rec. n @(Œª _: Nat. Nat) {
      | zero   ‚Ü¶ m
      | succ r ‚Ü¶ pred (minus-rec r)
      }.
lt : Nat ‚ûî Nat ‚ûî Bool
  = Œª m. Œª n.
      Œº' (minus m n) {
      | zero   ‚Ü¶ ff
      | succ r ‚Ü¶ tt
      }.
divide : Nat ‚ûî Nat ‚ûî Nat
  = Œª m. Œª n.
      Œº divide-rec. m @(Œª _: Nat. Nat) {
      | zero   ‚Ü¶ zero
      | succ r ‚Ü¶ [ m' = succ (fromNat/divide-rec r) ]
        - ite (lt m' n) zero
           ([ pred' = Œª x: Nat/divide-rec.
                Œº' x {| zero ‚Ü¶ x | succ x' ‚Ü¶ x'} ]
            - succ (divide-rec (iterate (pred n) pred' r)))
      }.
\end{verbatim}
  \caption{Histomorphic recursion and division}
  \label{fig:ex-data-div}
\end{figure}
We study more closely the strange types \verb;Nat/add-rec; and
\verb;Vec/append-rec;. The reader may well ask whether they serve any purpose
other than marking what recursive calls are legal in a function -- and the
answer is yes! Cedilleum uses types like these to support \textit{histomorphic}
or \textit{course-of-values} recursion, which is to say recursion schemes that
can dig arbitrarily deeply into the recursive occurences of data to compute
results. As a motivating example, we now show how we can define division on
natural numbers in Cedilleum using histomorphic recursion.

Languages with inductive datatypes and recursive function definitions that also
wish to have their type systems interpreted as sound logics must address the
issue of \textit{termination}, because the principle of general recursion
\verb;‚àÄ A: ‚òÖ. (A ‚ûî A) ‚ûî A; allows one to inhabit every type -- including ones we
want to be uninhabited! To that end, most such languages perform some
terminiation check separate from type checking that usually involves making sure
that arguments to recursive calls are getting \textit{structurally smaller} to
ensure that eventually a base case is reached. This check is necessarily
conservative (i.e. it will not accept all terminating functions), and the
classic example of a function that is not ``obviously'' terminating is division
on natural numbers by iterated subtraction. Intuitively, we understand that
subtracting \texttt{n} from \texttt{m} never produces a number larger than
\texttt{m} -- but it can be tricky to explain this to the termination checker!

The definition of division is given in Figure \ref{fig:ex-data-div}. We start by
defining some straightforward preliminaries: \texttt{iterate} for applying a
function some number of times to a base case, \texttt{minus} for subtraction,
and \texttt{lt} for a (boolean) predicate to test whether its first argument is
less than its second. In \texttt{divide} we kick off recursion on the numerator
\texttt{m}, and in the base case where it is \texttt{zero} we return
\texttt{zero}. When it is non-zero, we locally define \texttt{m'} by using
\texttt{fromNat/divide-rec} to cast the sub-data \texttt{r} of type
\texttt{Nat/divide-rec} back to \texttt{Nat}, where \texttt{fromNat/divide-rec}
is another automatically-generated in-scope of the body of the \texttt{Œº}
definition. We then use \texttt{ite} (mnemonic for ``if-then-else'') to see
whether our current numerator \texttt{m'} is less than the denominator, and if
so return \texttt{zero}.

The real action happens when the current numerator is larger than our
denominator, as we must make a recursive call to \texttt{divide-rec} after
subtracting (via iterated predecessor) \texttt{n} from \texttt{m'}. We declare a
version of predecessor \texttt{pred'} to operator over a term of type
\texttt{Nat/divide-rec} and define it in terms of \texttt{Œº'}. This is the key
to enabling histomorphic recursion -- \texttt{Œº'} allows for pattern matching on
both the ``concrete'' \texttt{Nat} and ``abstracted'' \texttt{Nat/divide-rec}
and can be iterated arbitrarily (here \texttt{pred n} times), but it 
\textit{cannot} be used to kick off its own recursion and \textit{cannot}
produce terms of the recursion-abstracted type \texttt{Nat/divide-rec} that are
larger than its input. Having define \texttt{pred'} this way, the rest of the
definition is straightforward: recursively call \texttt{divide-rec} after
performing ``abstracted'' subtraction via iterated predecessor on our
denominator (\texttt{iterate (pred n) pred' r}), and increment the result.

\subsection{Reasoning via Induction}
\label{sec:induction}
\begin{figure}[h]
\begin{verbatim}
add-zero-r : Œ† m: Nat. {add m zero ‚âÉ m}
  = Œª m. Œº' ih. m @(Œª x: Nat. {add x zero ‚âÉ x}) {
         | zero   ‚Ü¶ Œ≤
         | succ r ‚Ü¶ [eq = ih r]
             - œá {succ (add (fromNat/ih r) zero) ‚âÉ succ (fromNat/ih r)}
             - œÅ eq - Œ≤
         } .
\end{verbatim}
  \caption{A proof via induction}
  \label{fig:ex-data-ind}
\end{figure}
Figure \ref{fig:ex-data-ind} shows a simple proof that \texttt{zero} is the
right identity of \texttt{add} using induction on \texttt{Nat}. At a high level,
it proceeds mostly as usual, but in the inductive \texttt{succ} case some care
must be taken to mediate between the motive \verb;Œª x: Nat. {add x zero ‚âÉ x};
phrased over \texttt{Nat}s, the type of \texttt{ih}, and the type expected for
the result of each branch. Previously, we saw for the non-dependent case that
\texttt{Œº}-bound recursive functions like \texttt{ih} accept as arguments
recursive-occurrence types like \texttt{Nat/ih}; in the dependent case, the
result type / proof always mentions the bound variable as being \textit{casted
  back} to the original type. In this particular example, the type of
\texttt{ih} is therefore \verb;Œ† x: Nat/ih. {add (fromNat/ih x) zero ‚âÉ fromNat/ih x};.

As for the branches, in the base case \texttt{zero} the required branch type is
the usual \verb;{add zero zero ‚âÉ zero}; which comes from simple Œ≤-reduction. In
the step case \texttt{succ r} the required branch type is more subtle --
\verb;{add (succ (fromNat/ih r)) zero ‚âÉ succ (fromNat/ih r)};, where the cast
function has been pushed into the constructor arguments. (In general the
sub-data for such constructors is $\eta$-expanded in the motive until the cast
has a target to apply to -- see Section \ref{sec:positive-data} for more). Here,
we first invoke \texttt{ih} to produce \texttt{eq} of type
\verb;{add (fromNat/ih r) zero ‚âÉ fromNat/ih r};. Next, we need to get the type system to
Œ≤-reduce the expected branch type a bit so that we can rewrite by \texttt{eq}. To that
end, we check the remainder of branch with œá against the type
\verb;{succ (add (fromNat/ih r) zero) ‚âÉ succ (fromNat/ih r)};, which is convertible with the
expected type (note that the difference is that constructor \texttt{succ} has
been pushed outside of the call to \texttt{add}). Finally, we can use œÅ to
rewrite \textit{this} expected type by the equality \texttt{eq}, producing
expected type \verb;{succ (fromNat/ih r) ‚âÉ succ (fromNat/ih r)}; which is true
Œ≤, the reflexivity rule for equality.

\subsection{Reduction Rules of Œº and Œº'}
In the preceding section there was a tiny white lie. The expected type
corresponding to the branch \texttt{succ r} is \texttt{\{add (succ (fromNat/ih
  r)) zero ‚âÉ succ (fromNat/ih r)\}}, and we \textit{said} we used the type annotation
construct \texttt{œá} to get this to Œ≤-reduce to a suitable type. However, using
Œ≤-reduction alone, the normalized branch type is actually
\begin{verbatim}
{ succ (Œº add-rec. (fromNat/ih r)) {
    | zero   ‚Ü¶ zero
    | succ p ‚Ü¶ succ (add-rec p)
  } ‚âÉ succ (fromNat/ih r)
}
\end{verbatim}
First, the arguments \texttt{succ (fromNat/ih r)} and \texttt{zero} are
substituted into the body of \texttt{add}. Then, we note that the scrutinee
\texttt{succ (fromNat/ih r)} of Œº matches one of the given branches (the
\texttt{succ} branch), so by what is known as Œ¥-reduction we replace the entire
Œº expression with the branch body, substituting the variable \texttt{p} bound at
the branch with the value \texttt{(fromNat/ih r)}. Constructs Œº and \texttt{Œº'}
have this Œ¥-reduction in common, and if we were normalzing a \texttt{Œº'}
expression this would be the end of the reduction step. For Œº however, if we
just stopped here we would have a problem -- the result of substitution would be
\texttt{succ (add-rec (fromNat/ih r))}, but \texttt{add-rec} was bound by the
\texttt{Œº} expression we just removed! This is remedied by substituting it away
for the original Œº expression, producing the expected type given above.

There is one more form of reduction that may surprise the reader, and that is
the behavior of the generated Œº-bound casting functions like
\texttt{fromNat/ih}. The expression \texttt{fromNat/ih r} actually reduces, in a
single step, to \texttt{r}! This may seem quite strange, as these two
expressions do not even have the same type, but Cedilleum (like Cedille) is an
extrinsic type theory in which a single (untyped) term can be given ascribed
types and in which type preservation does not hold. For more on this, see
\cite{St18_Cedille-Syntax-Semantics}.

\subsection{Non-strictly Positive Datatypes}
\label{sec:positive-data}
In the preceeding sections, we have that seen ``cast'' functions like
\texttt{Nat/ih} (in Figure \ref{fig:ex-data-ind}) show up in the the expected
type of a case branch, and also have noted already that Cedilleum allows for
positive but not strictly positive data type defintions. We now take a look at
how these two things interact.

\begin{figure}[h]
\begin{verbatim}
data PTree : ‚òÖ =
  | leaf : PTree
  | node : ((PTree ‚ûî Bool) ‚ûî PTree) ‚ûî PTree
.
PTreeSel : ‚òÖ = (PTree ‚ûî Bool) ‚ûî PTree.
indTree : ‚àÄ P: PTree ‚ûî ‚òÖ.
    P leaf ‚ûî (‚àÄ s: PTreeSel. (Œ† p: PTree ‚ûî Bool. P (s p)) ‚ûî P (node s))
    ‚ûî Œ† t: PTree. P t
  = Œõ P. Œª base. Œª step. Œª t. Œº ih. t @(Œª x: PTree. P x) {
      | leaf   ‚Ü¶ base
      | node s ‚Ü¶
        [ conv-p : (PTree ‚ûî Bool) ‚ûî PTree/ih ‚ûî Bool
          = Œª p. Œª r. p (fromPTree/ih r) ]
        - [ s' : PTreeSel = Œª p. fromPTree/ih (s (conv-p p)) ]
        - step -s' (Œª p. ih (s (conv-p p)))
      }.
\end{verbatim}
  \caption{A non-strictly positive infinitary tree}
  \label{fig:ptree}
\end{figure}

Figure \ref{fig:ptree} presents a definition of \texttt{PTree}, an infinitary
tree which is not strictly positive in the \texttt{node} constructor, and a
proof of induction for it using Œº. One intuition for what kind of terms inhabit
\texttt{PTree} is ``at a \texttt{node}, there must be some way of selecting one
\texttt{PTree} (of infinitely many) from some partition \texttt{PTree ‚ûî Bool}''.
The branch given by pattern \texttt{leaf} is the \texttt{base} case, requring a
proof of \texttt{P leaf} which we have by assumption. For the \texttt{step} case
given by the branch for pattern \texttt{node}, the expected type is the trickier
\texttt{P (node s')}, where \texttt{s'} is defined as above. Recall that in our
branch the constructor arguments have all recursive occurences of their
inductive type replaced with a special ``abstracted'' version. In the case of
\texttt{leaf}, the subdata \texttt{s} has type \texttt{(PTree/ih ‚ûî Bool) ‚ûî
PTree/ih}. The the naive expected branch type \texttt{P (node s)} given by
simply substituting the pattern in for the bound \texttt{x} given in the motive
is not well-kinded! To fix this we $\eta$-expand and cast using \texttt{fromPTree/ih}
as needed to produce the appropriate expected type.

Now we examine the body of the \texttt{node} branch itself more closely. First,
we need a way to convert any ``partition'' \texttt{p} of type \texttt{PTree ‚ûî
  Bool} to \texttt{PTree/ih ‚ûî Bool} so that it can operate over terms of the abstracted
type. With this we can do the same for our selector \texttt{s}, producing
\texttt{s'}. Finally, we invoke \texttt{step} so that we can have prove
\texttt{P (node s')} as desired. The second argument of \texttt{step} requires a
proof that \texttt{P (s' p)} holds for any \texttt{p}. To show this, we take the
assumed \texttt{p}, ``weaken'' it to work over the abstracted recursive types
with \texttt{conv-p}, and pass this to \texttt{s} (and not \texttt{s'}!) to
produce a value of type \texttt{PTree/ih} suitable for consumption by
\texttt{ih}, which has type \texttt{Œ† t: PTree/ih. P (fromPTree/ih t)}. Note
again that the proof we need to give here, \texttt{P (s' p)}, is convertible
with the proof \texttt{P (fromPTree/ih (s (conv-p p)))} that the call to
\texttt{ih} actually returns.

\section{Syntax}
\label{sec:syntax}

\paragraph{Identifiers}
\begin{figure}[h]
  \[
    \begin{array}{llll}
      id & &
      & \textnormal{identifiers for definitions}
      \\ u,c & &
      & \textnormal{term variables}
      \\ X & &
      & \textnormal{type variables}
      \\ ùíå & &
      & \textnormal{kind variables}
      \\ x & ::= & id\ |\ u\ |\ X\
      & \textnormal{non-kind variables}
      \\ y & ::= & x\ |\ ùíå & \text{all variables}
    \end{array}
  \]
  \caption{Identifiers}
  \label{fig:identifiers}
\end{figure}

We now turn to a more formal treatment of Cedilleum. Figure
\ref{fig:identifiers} gives the metavariables used in our grammar for
identifiers. We consider all identifiers as coming from two distinct lexical
``pools'' -- regular identifiers (consisting of identifiers $id$ given for
modules and definitions, term variables $u$, and type variables $X$) and kind
identifiers $\kappa$. In Cedilleum source files (as in the parent language
Cedille) kind variables should be literally prefixed with $\kappa$ -- the suffix
can be any string that would by itself be a legal non-kind identifier. For
example, \texttt{myDef} is a legal term / type variable and a legal name for a
definition, whereas \texttt{ùíåmyDeff} is only legal as a kind definition.

\paragraph{Untyped Terms}
\begin{figure}[h]
  \[
    \begin{array}{llll}
      p
      & ::= & u
      & \text{variables}
      \\ & & \absu{\textbf{Œª}}{u}{p}
      & \text{functions}
      \\ & & p\ p
      & \text{applications}
      \\ & & \mufix{u}{p}{pcase^*}
      & \text{fixed-point and pattern matching}
      \\ & & \mumat{p}{pcase^*}
      & \text{simple pattern matching}
      \\ \\ pcase
      & ::= & \textbf{\textbar}\ u\ u^* \mapsto p
    \end{array}
  \]
  \caption{Untyped terms}
  \label{fig:pure-terms}
\end{figure}

The grammar of pure (untyped) terms the untyped Œª-calculus augmented with a
primitives for combination fixed-point and pattern-matching definitions (and an
auxiliary pattern-matching construct).

\begin{figure}[h]
  \[
    \begin{array}{llll}
      % module stuff
      \\ mod
      & ::= & \textbf{module}\ id\ \textbf{.}\ imprt^*\ cmd^*\
      & \textnormal{module declarations}
      \\ imprt
      & ::= & \textbf{import}\ id\ \textbf{.}
      & \textnormal{module imports}
      \\ cmd
      & ::= & defTermOrType
      & \textnormal{definitions}
      \\ & & defDataType
      \\ & & defKind
      % definitions
      \\ 
      \\ defTermOrType
      & ::= & id\ checkType^?\ \textbf{=}\ t\ \textbf{.}
      & \textnormal{term definition}
      \\ & & id\ \textbf{:}\ K\ \textbf{=}\ T\ \textbf{.}
      & \textnormal{type definition}
      \\ defKind
      & ::= & ùíå\ \textbf{=}\ K
      & \text{kind definition}
      \\ defDataType
      & ::= & \textbf{data}\ id\ param^*\ \textbf{:}\ K\ \textbf{=}\
              constr^*\ \textbf{.}
      & \textnormal{datatype definitions}
     % auxilliary categories for definitions
      \\ 
      \\ checkType
      & ::= & \textbf{:}\ T
      & \textnormal{annotation for term definition}
      \\ param
      & ::= & \textbf{(}x\ \textbf{:}\ C \textbf{)}
      \\ constr
      & ::= & \textbf{\textbar}\ id\ \textbf{:}\ T
    \end{array}
  \]
  \caption{Modules and definitions}
  \label{fig:mods-defs}
\end{figure}

\paragraph{Modules and Definitions}
All Cedilleum source files start with production $mod$, which consists of a module
declaration, a sequence of import statements which bring into scope definitions
from other source files, and a sequence of \textit{commands} defining terms,
types, and kinds. As an illustration, consider the first few lines of a
hypothetical \texttt{list.ced}:

\begin{verbatim}
module list .

import nat .
\end{verbatim}

\noindent Imports are handled first by consulting a global options files
known to the Cedilleum compiler (on *nix systems \verb|~/.cedille/options|)
containing a search path of directories, and next (if that fails) by searching
the directory containing the file being checked.

Term and type definitions are given with an identifier, a classifier (type or
kind, resp.) to check the definition against, and the definition. For term
definitions, giving classifier (i.e. the type) is optional. As an example,
consider the definitions for the type of Church-encoded lists and two variants
of the nil constructor, the first with a top-level type annotation and the
second with annotations sprinkled on binders:

\begin{verbatim}
cList : ‚òÖ ‚ûî ‚òÖ
      = Œª A : ‚òÖ . ‚àÄ X : ‚òÖ . (A ‚ûî X ‚ûî X) ‚ûî X ‚ûî X .

cNil  : ‚àÄ A : ‚òÖ . cList ¬∑ A
      = Œõ A . Œõ X . Œª c . Œª n . n .
cNil' = Œõ A : ‚òÖ . Œõ X : ‚òÖ . Œª c : A ‚ûî X ‚ûî X . Œª n : X . n .
\end{verbatim}

Kind definitions are given without classifiers (all kinds have super-kind
$\Box$), e.g. \verb;ùíåfunc = ‚òÖ ‚ûî ‚òÖ;

Inductive datatype definitions take a set of \textit{parameters} (term and type
variables which remain constant throughout the definition) well as a set of
\textit{indices} (term and type variables which \textit{can} vary), followed by
zero or more constructors. Each constructor begins with ``\textbf{\textbar}''
(though the grammar can be relaxed so that the first of these is optional) and
then an identifier and type is given. As an example, consider the following two
definitions for lists and vectors (length-indexed lists).

\begin{verbatim}
data Bool : ‚òÖ =
  | tt : Bool
  | ff : Bool
  .

data Nat : ‚òÖ =
  | zero : Nat
  | suc  : Nat ‚ûî Nat
  .

data List (A : ‚òÖ) : ‚òÖ =
  | nil  : List
  | cons : A ‚ûî List ‚ûî List
  .
data Vec (A : ‚òÖ) : Nat ‚ûî ‚òÖ =
  | vnil  : Vec zero
  | vcons : ‚àÄ n: Nat. A ‚ûî Vec n ‚ûî Vec (succ n)
  .
\end{verbatim}

\paragraph{Types and Kinds}
\begin{figure}[h]
  \[
    \begin{array}{rlll}
      \text{Sorts } S
      & ::= & \square & \text{sole super-kind}
      \\ & & K & \text{kinds}
      \\ \text{Classifiers } C
      & ::= & K & \text{kinds}
      \\ & & T & \text{types}
      \\ \text{Kinds } K
      & ::= & \textbf{Œ†}\ x\ \textbf{:}\ C\ \textbf{.}\ K
      & \textnormal{explicit product}
      \\ & & C\ \textbf{‚ûî}\ K
      & \textnormal{kind arrow}
      \\ & & \textbf{‚òÖ}
      & \text{the kind of types that classify terms}
      \\ & & \textbf{(}K\textbf{)}
      \\ 
      \\ \text{Types } T
      & ::= & \textbf{Œ†}\ x\ \textbf{:}\ T\ \textbf{.}\ T
         & \textnormal{explicit product}
      \\ & &  \textbf{‚àÄ}\ x\ \textbf{:}\ C\ \textbf{.}\ T
         & \textnormal{implicit product}
      \\ & &  \textbf{Œª}\ x\ \textbf{:}\ C\ \textbf{.}\ T
         & \textnormal{type-level function}
      \\ & & T\ \textbf{‚ûæ}\ T'
         & \textnormal{arrow with erased domain}
      \\ & & T\ \textbf{‚ûî}\ T'
         & \textnormal{normal arrow type}
      \\ & & T\ \textbf{¬∑}\ T'
         & \text{application to another type}
      \\ & & T\ t
         & \text{application to a term}
      \\ & & \textbf{\{}\ p\ ‚âÉ\ p' \textbf{\}}
         & \textnormal{untyped equality}
      \\ & & \textbf{(}T\textbf{)}
      \\ & & X
         & \text{type variable}
      \\ & & \bullet
         & \text{hole for incomplete types}
    \end{array}
  \]
  \caption{Kinds and types}
  \label{fig:kinds-types}
\end{figure}

In Cedilleum, the expression language is stratified into three main ``classes'':
kinds, types, and terms. Kinds and types are listed in Figure
\ref{fig:kinds-types} and terms are listed in Figure \ref{fig:ann-terms} along
with some auxiliary grammatical categories. In both of these figures, the
constructs forming expressions are listed from lowest to highest precedence --
``abstractors'' ($\lambda\ \Lambda\ \Pi\ \forall$) bind most loosely and
parentheses most tightly. Associativity is as-expected, with arrows (‚ûî ‚ûæ) and
applications being left-associative and abstractors being right-associative.

% TODO cite
The language of kinds and types is similar to that found in the Calculus of
Implicit Constructions\footnote{Cite}. Kinds are formed by dependent and
non-dependent products (Œ† and ‚ûî) and a base kind for types which can classify
terms (‚òÖ). Types are also formed by the usual (dependent and non-dependent)
products (Œ† and ‚ûî) and also \textit{implicit} products (‚àÄ and ‚ûæ) which quantify
over erased arguments (that is, arguments that disappear at run-time).
Œ†-products are only allowed to quantify over terms as all types occurring in
terms are erased at run-time, but ‚àÄ-products can quantify over types
\textit{and} terms because terms can be erased. Meanwhile, non-dependent
products (‚ûî and ‚ûæ) can only ``quantify'' over terms because non-dependent type
quantification does not seem particularly useful. Besides these, Cedilleum
features type-level functions and applications (with term and type arguments),
and a primitive equality type for untyped terms. Last of all is the ``hole''
type (‚óè) for writing partial type signatures or incomplete type applications.
There are term-level holes as well, and together the two are intended to help
facilitate ``hole-driven development'': any hole automatically generates a type
error and provides the user with useful contextual information.

We illustrate with another example: what follows is a module stub for
\textbf{DepCast} defining dependent casts -- intuitively, functions from $a : A$
to $B\ a$ that are also equal\footnote{Module erasure, discussed below} to
identity -- where the definitions \texttt{CastE} and \texttt{castE} are
incomplete.

\begin{verbatim}
module DepCast .

CastE ‚óÇ Œ† A : ‚òÖ . (A ‚ûî ‚òÖ) ‚ûî ‚òÖ = ‚óè .

castE ‚óÇ ‚àÄ A : ‚òÖ . ‚àÄ B : A ‚ûî ‚òÖ . CastE ¬∑ A ¬∑ B ‚ûæ Œ† a : A . B a = ‚óè .
\end{verbatim}

\paragraph{Annotated Terms}
\begin{figure}[h]
  \[
    \begin{array}{rlll}
      \text{Subjects } s
      & ::= & t & \text{term}
      \\ & & T & \text{type}
      \\ \text{Terms } t
      & ::= & \textbf{Œª}\, x\ class^?\! \textbf{.}\, t
      & \textnormal{normal abstraction}
      \\ & & \textbf{Œõ}\, x\ class^?\! \textbf{.}\, t
      & \textnormal{erased abstraction}
      \\ & & \textbf{[}\ defTermOrType\ \textbf{]}\ \textbf{-}\ t
      & \text{let definitions}
      \\ & & \textbf{œÅ}\ t\ \textbf{-}\ t'
      & \text{equality elimination by rewriting}
      \\ & & \textbf{œÜ}\ t\ \textbf{-}\ t'\ \textbf{\{} t'' \textbf{\}}
      & \text{type cast}
      \\ & & \textbf{œá}\ T\ \textbf{-}\ t
      & \text{check a term against a type}
      \\ & & \textbf{Œ¥}\ \textbf{-}\ t
      & \text{ex falso quodlibet}
      \\ & & \textbf{Œ∏}\ t\ t'^*
      & \text{elimination with a motive}
      \\ & & t\ t'
      & \text{applications}
      \\ & & t\ \textbf{-}t'
      & \text{application to an erased term}
      \\ & & t\ \textbf{¬∑}T
      & \text{application to a type}
      \\ & & \textbf{Œ≤}\ \textbf{\{} t \textbf{\}}
      & \textnormal{reflexivity of equality}
      \\ & & \textbf{œÇ}\ t
      & \textnormal{symmetry of equality}
      \\ & & \mufix{u}{t\ motive^?}{case^*}
      & \textnormal{type-guarded pattern match and fixpoint}
      \\ & & \mumat{t\ motive^?}{case^*}
      & \text{auxiliary pattern match}
      \\ & & u
      & \text{term variable}
      \\ & & \textbf{(}t\textbf{)}
      \\ & & \bullet
      & \text{hole for incomplete term}
      \\ \\ case
      & ::= & \textbf{\textbar}\ c\ vararg^*\ \textbf{‚Ü¶}\ t
      & \text{pattern-matching cases}
      \\ vararg
      & ::= & u
      & \text{normal constructor argument}
      \\ & & \textbf{-}u
      & \text{erased constructor argument}
      \\ & & \textbf{¬∑}X
      & \text{type constructor argument}
      \\ class
      & ::= & \textbf{:}\ C
      \\ motive
      & ::= & \textbf{@}\ T
      & \textnormal{motive for induction}
    \end{array}
  \]
  \caption{Annotated Terms}
  \label{fig:ann-terms}
\end{figure}

Terms can be explicit and implicit functions (resp. indicated by Œª and Œõ) with
optional classifiers for bound variables, let-bindings, applications $t\ t'$,
$t\ \mhyph t'$, and $t\ \cdot T$ (resp. to another term, an erased term, or a
type). In addition to this there are a number of useful operators for
equaltional reasoning, type casting, providing annotations, and pattern
matching. Each operator will be discussed in more detail in Section
\ref{sec:type-system}, but a few concrete programs in Cedilleum are given below
merely to give a better idea of the syntax of the language.

\begin{verbatim}
isvnil : ‚àÄ A: ‚òÖ. ‚àÄ n: Nat. Vec ¬∑A n ‚ûî Bool
       = Œõ A. Œõ n. Œª xs. Œº' xs @(Œõ n . Œª xs . Bool) {
           | vnil          ‚Ü¶ tt
           | vcons -n x xs ‚Ü¶ ff
           }.
vlength : ‚àÄ A: ‚òÖ. ‚àÄ n: Nat. Vec ¬∑A n ‚ûî Nat
        = Œõ A. Œõ n. Œª xs. Œº len . xs @(Œõ n . Œª x . Nat) {
            | vnil          ‚Ü¶ zero
            | vcons -n x xs ‚Ü¶ suc (len -n xs)
            }.
\end{verbatim}

\section{Erasure}

\begin{figure}[h]
  \[
  \begin{array}{lll}
       |x| & = & x 
    \\ |\star| & = & \star 
    \\ |\Box| & = & \Box 
    \\ |\beta\ \{t\}| & = & |t|
    \\ |\delta\ t| & = & |t|
    \\ |\chi\ T^? \textbf{-}\ t| & = & |t| 
    \\ |\varsigma\ t| & = & |t|
    \\ |t\ t'| & = & |t|\ |t'|
    \\ |t\ \mhyph t'| & = & |t| 
    \\ |t\ \cdot T| & = & |t| 
    \\ |\rho\ t\ \mhyph\ t'| & = & |t'| 
    \\ |\abs{\forall}{x}{C}{C'}| & = & \abs{\forall}{x}{|C|}{|C'|}
    \\ |\abs{\Pi}{x}{C}{C'}| & = & \abs{\Pi}{x}{|C|}{|C'|}
    \\ |\abs{\lambda}{u}{T}{t}| & = &  \absu{\lambda}{u}{|t|} 
    \\ |\absu{\lambda}{u}{t}| & = &  \absu{\lambda}{u}{|t|} 
    \\ |\abs{\lambda}{X}{K}{C}| & = &  \abs{\lambda}{X}{|K|}{|C|} 
    \\ |\abs{\Lambda}{x}{C}{t}| & = &  |t| 
    \\ |\phi\ t\ \mhyph\ t'\ \{t''\}| & = & |t''| 
    \\ |[ x = t : T]|\ \mhyph\ t' | & = & (\absu{\lambda}{x}{|t'|})\ |t|
    \\ |[X = T : K]\ \mhyph\ t | & = & |t| 
    \\ |\{ t \simeq t' \}|| & = & \{ |t| \simeq |t'| \}
    \\ |\mufix{u,}{t\ motive^?}{case^*}|
           & = & \mufix{u}{|t|}{|case^*|}
    \\ |\mumat{t\ motive^?}{case^*}|
           & = & \mumat{|t|}{|case^*|}
    \\ \\ |id\ vararg^* \mapsto t| & = & id\ |vararg^*|\ \mapsto |t|
    \\ 
    \\ |\mhyph u| & = & 
    \\ |\cdot X|  & = &
  \end{array}
  \]
  \caption{Erasure for annotated terms}
  \label{fig:eraser}
\end{figure}

The definition of the erasure function given in Figure \ref{fig:eraser} takes
the annotated terms from Figures \ref{fig:kinds-types} and \ref{fig:ann-terms} to
the untyped terms of Figure \ref{fig:pure-terms}. The last two equations
indicate that any type or erased arguments in the the zero or more $vararg$'s of
pattern-match case are indeed erased. The additional constructs introduced in
the annotated term language such as Œ≤, œÜ, and œÅ, are all erased to the language
of pure terms.

\section{Type System (sans Inductive Datatypes)}
\label{sec:type-system}

\begin{figure}[h]
  \caption{Contexts}
  \[
    \begin{array}{llll}
      \text{ Typing contexts } \Gamma
      & ::= & \emptyset\ |\ \ann{x}{C},\Gamma\ |\ \ann{x=s}{C},\Gamma
    \end{array}
  \]
\end{figure}
\begin{figure}[h!]
  \[ \small
    \begin{array}{lcr}
      \infer{\Gamma\vdash \star : \Box}{\ }
      & \infer
        { \Gamma\vdash\abs{\Pi}{y}{C}{C'} : S'}
        { \Gamma \vdash C : S
        \quad
        \Gamma,y:C\vdash C' : S'
%        \quad \textit{Var}(y,S)
        }
      & \infer
        {\Gamma\vdash\abs{\forall}{y}{C}{C'} : \star}
        {\Gamma \vdash C : S
        \quad \Gamma,y:C\vdash C' : \star
%        \quad \textit{Var}(y,S)
        }
      \\
      \\ \infer
      { \Gamma \vdash \{p \simeq p' \} : \star}
      { FV(p\ p') \subseteq dom(\Gamma) }
      & \infer
        { \Gamma \vdash \kappa : \Gamma(\kappa)}
        { }
      & \infer
        { \Gamma \vdash X : \Gamma(X)}
        { }
      \\
      \\ \infer
      { \Gamma \vdash \abs{\lambda}{x}{C}{T} : \abs{\Pi}{x}{C}{K}}
      { \Gamma \vdash \abs{\Pi}{x}{C}{K} : \square
      \quad \Gamma, \ann{x}{C} \vdash T : K
      }
      & \infer
        { \Gamma \vdash T\ \cdot T' : [T'/x] K'}
        { \Gamma \vdash T : \abs{\Pi}{x}{K}{K'}
        \quad \Gamma \vdash T' : K}
      & \infer
       { \Gamma \vdash T\ t : [t/x] K}
        { \Gamma \vdash T : \abs{\Pi}{x}{T'}{K}
        \quad \Gamma \decchk t : T' }
    \end{array}
  \]
  \caption{Sort checking \fbox{$\Gamma \vdash C : S$}}
  \label{fig:sort-checking}
\end{figure}

\begin{figure}[h!]
  \[ \small
    \begin{array}{lcr}
      \infer
      { \Gamma \decdir u : \Gamma(u)}{}
      & \infer
        { \Gamma \decdir \abs{\lambda}{x}{T}{t} : \abs{\Pi}{x}{T}{T'}}
        { \Gamma \vdash T : K
        \quad \Gamma, \ann{x}{T} \decdir t : T'}
      & \infer
        { \Gamma \decchk \absu{\lambda}{x}{t} : \abs{\Pi}{x}{T}{T'}}
        { \Gamma, \ann{x}{T} \decchk t : T'}
      \\
      \\ \infer
      { \Gamma \decdir \abs{\Lambda}{x}{C}{t} : \abs{\forall}{x}{C}{T}}
      { \Gamma \vdash C : S
      \quad x \notin FV(|t|)
      \quad \Gamma, \ann{x}{C} \decdir t : T
      }
      & \infer
        { \Gamma \decchk \absu{\Lambda}{x}{t} : \abs{\forall}{x}{C}{T}}
        { x \notin FV(|t|)
        \quad \Gamma, \ann{x}{C} \decdir t : T
        }
      & \infer
        { \Gamma \decdir t\ t' : [t'/x]T}
        { \Gamma \decsyn t : \abs{\Pi}{x}{T'}{T}
        \quad \Gamma \decchk t' : T'}
      \\
      \\ \infer
      { \Gamma \decdir t\ \cdot T : [T/X]T'}
      { \Gamma \decsyn t : \abs{\forall}{X}{K}{T'}
      \quad \Gamma \vdash T : K}
      & \infer
        { \Gamma \decdir t\ \mhyph t' : [t'/x]T}
        { \Gamma \decsyn t : \abs{\forall}{x}{T'}{T}
        \quad \Gamma \decchk t' : T'}
      & \infer % conversion... maybe needs to include phi and rho now?
        { \Gamma \decchk t : T }
        { \Gamma \decsyn t : T'
          & |T'| =_{\beta} |T| }
      \\ \\ \infer
      { \Gamma \decdir [ id : T = t ]\ \mhyph\ t' : T'}
      { \Gamma \vdash T : K
        & \Gamma \decchk t : T
        & \Gamma, \ann{id = t}{T} \decdir t' : T'}
      & \infer
        { \Gamma \decdir [ id = t]\ \mhyph\ t' : T' }
        { \Gamma \decsyn t : T
          & \Gamma, \ann{id = t}{T} \decdir t' : T'
        }
      & \infer[\footnotemark] % TODO
        { \Gamma \decdir \rho\ t\ \mhyph\ t' : [t_2/x]\ T}
        { \Gamma \decsyn t : \{ t_1 \simeq t_2 \}
          & \Gamma \decsyn t' : [t_1/x]\ T
        }
      \\ \\ \infer
      { \Gamma \decdir [ id : K = T ]\ \mhyph\ t' : T'}
      { \Gamma \vdash K : \square
        & \Gamma \vdash T : K
        & \Gamma, \ann{id = T}{K} \decdir t' : T'}
      & \infer
        { \Gamma \decchk \beta \{t\} : \{ t' \simeq t' \}}
        { \Gamma \vdash \{ t' \simeq t' \} : \star }
      & \infer
        { \Gamma \decdir \varsigma\ t : \{ t_2 \simeq t_1 \} }
        { \Gamma \decdir t : \{ t_1 \simeq t_2 \}}
      \\ \\ \infer
      { \Gamma \decdir \phi\ t\ \mhyph\ t_1\ \{t_2\} : T}
      { \Gamma \decchk t : \{ |t_1| \simeq |t_2| \}
        & \Gamma \decdir t_1 : T}
      & \infer
        { \Gamma \decsyn \chi\ T\ \mhyph\ t : T }
        { \Gamma \decchk t : T }
      & \infer[\footnotemark]
        { \Gamma \decchk \delta\ \mhyph\ t : T }
        { \Gamma \decchk t : \{ \texttt{tt}\ \simeq\ \texttt{ff} \}}
    \end{array}
  \]
  \caption{Type checking \fbox{$\Gamma \decdir s : C$} (sans inductive datatypes)}
  \label{fig:type-checking}
\end{figure}
\footnotetext{Where we assume $t$ does not occur anywhere in $T$}
\footnotetext{Where $\texttt{tt} = \absu{\lambda}{x}{\absu{\lambda}{y}{x}}$ and
  $\texttt{ff} = \absu{\lambda}{x}{\absu{\lambda}{y}{y}}$}
% TODO kind-variables... two different rules or Var check?
% TODO equality, now that it can have rho, phi

The inference rules for classifying expressions in Cedilleum are stratified into
two judgments. Figure \ref{fig:sort-checking} gives the uni-directional rules
for ensuring types are well-kinded and kinds are well-formed. Future versions of
Cedilleum will allow for bidirectional checking for both typing \textit{and}
sorting, allowing for a unification of these two figures. Most of these rules
are similar to what one would expect from the Calculus of Implicit
Constructions, so we focus on the typing rules unique to Cedilleum.

The typing rule for œÅ shows that œÅ is a primitive for rewriting by an (untyped)
equality. If $t$ is an expression that synthesizes a proof that two terms $t_1$
and $t_2$ are equal, and $t'$ is an expression synthesizing type $[t_1/x]\ T$
(where, as per the footnote, $t_1$ does not occur in $T$), then we may
essentially rewrite its type to $[t_2/x]\ T$. The rule for Œ≤ is reflexivity for
equality -- it witnesses that a term is equal to itself, provided that the type
of the equality is well-formed. The rule for œÇ is symmetry for equality.
Finally, œÜ acts as a ``casting'' primitive: the rule for its use says that if
some term $t$ witnesses that two terms $t_1$ and $t_2$ are equal, and $t_1$ has
been judged to have type $T$, then intuitively $t_2$ can also be judged to have
type $T$. (This intuition is justified by the erasure rule for œÜ -- the
expression erases to $|t_2|$). The last rule involving equality is for Œ¥, which
witnesses the logical principle \textit{ex falso quodlibet} -- if a certain
impossible equation is proved (namely that the two Church-encoded booleans
\texttt{tt} and \texttt{ff} are equal), then \textit{any} type desired is
inhabited. The remaining primitive œá allows the user to provide an
explicit top-level annotation for a term.

\section{Inductive Datatypes}

Before we can provide the typing rules for introduction and usage of inductive
datatypes, some auxiliary definitions must be given. The syntax for these, and
the structure of this entire section, borrows heavily from the conventions of the Coq
documentation\footnote{https://coq.inria.fr/refman/language/cic.html\#inductive-definitions}.
The author believes it is worthwhile to restate this development in terms of the
Cedilleum type system, rather than merely pointing readers to the Coq
documentation and asking them to infer the differences between the two systems.

To begin with, the production $defDataType$ gives the concrete syntax for datatype definitions,
but it is not a very useful notation for representing one in the abstract syntax
tree. In our typing rules we will instead use the notation
$\indast{M}{p}{\Gamma_I}{\Sigma}$, where

\begin{itemize}
\item $M$ is a meta-variable ranging over
  constant labels ``C'' and ``A'' (used to distinguish \textbf{c}oncrete and
  \textbf{a}bstracted inductive definitions -- more on this below)
\item $p$ is the number of \textbf{p}arameters of the inductive definition
\item $\Gamma_I$ is a typing context binding \textit{one} type variable $I$, the
  inductive type being defined
\item $\Sigma$ is a typing context containing the $n$ data constructors
  $c_1,...,c_n$ of $I$.
\end{itemize}

For example, consider the \texttt{List} and \texttt{Vec} definitions from
Section \ref{sec:syntax}. These will be represented in the AST as
\\ \\
\[\indast{\text{C}}{1}{List : ‚òÖ ‚ûî ‚òÖ}
{\begin{array}{lcl}
   nil & : & ‚àÄ A : ‚òÖ . List \cdot A
   \\ cons & : & ‚àÄ A : ‚òÖ . A ‚ûî List \cdot A ‚ûî List \cdot A
 \end{array}
}\] and
\\
\[\indast{\text{C}}{1}{Vec : ‚òÖ ‚ûî Nat ‚ûî ‚òÖ}
{\begin{array}{lcl}
   vnil & : & ‚àÄ A: ‚òÖ.Vec \cdot\!A\ zero
   \\ vcons & : & ‚àÄ A: ‚òÖ. ‚àÄ n :Nat. A ‚ûî Vec \cdot\!A\ n ‚ûî Vec \cdot\!A\ (succ\ n)
 \end{array}
}\]

\noindent All inductive types the user will define will be concrete inductive
defintions, and have global scope. Abstracted definitions are automiatically
generated during fix-point pattern matching, and have local scope.

For an inductive datatype definition to be well-formed, it must satisfy the
following conditions (each of which is explained in more detail in Subsections
\ref{ssec:inductive-aux-defs} and \ref{ssec:inductive-wf-def}):

\begin{itemize}
\item The kind of $I$ must be (at least) a \textit{p-arity of kind ‚òÖ}.
\item The types of each $id \in \Sigma$ must be \textit{types of constructors
    of $I$}
\item The definition must satisfy the \textit{non-strict} positivity condition.
\end{itemize}

Similarly, the notation in the grammar of Cedilleum $\mu'$ and $\mu$ for pattern
matching is inconvenient, and we will represent them in the AST as resp.
$\mu'(t,P,t_{i=1..n})$ and
$\mu(x_{\text{rec}},I',x_{\text{to}},t,P,t_{i=1..n})$. Translation from the form
given in the grammar to this form is discussed in detail below, but is as
expected. In particular, we enforce that patterns are exhaustive and
non-overlapping, and that $I'$ and $x_{\text{to}}$ (which correspond to the
automatically generated identifiers like \texttt{Nat/ih} and \texttt{fromNat/ih}
from the introduction) are fresh w.r.t the global and local
context. For example, consider the pattern-matches given in the code listings
for \texttt{isvnil} and \texttt{vlength} above. These would be translated into
the AST as
\\ \\
\[
  \mu'(xs,\absu{\Lambda}{n}{\absu{\lambda}{x}{Bool}},
  \begin{array}{l}
    \absu{\texttt{tt}}
    \\ \absu{\Lambda}{n}{\absu{\lambda}{x}{\absu{\lambda}{xs}{\texttt{ff}}}}
  \end{array}
  )
\] and
\[ \mu(len, Vec/len, fromVec/len,xs,\absu{\Lambda}{n}{\absu{\lambda}{x}{Nat}},
  \begin{array}{l}
    \texttt{zero}
    \\ \absu{\Lambda}{n}{\absu{\lambda}{x}{\absu{\lambda}{xs}{succ\ (len\ \mhyph
    n\ xs)}}}
    % \absu{\Lambda}{n}{\absu{\Lambda}{m}{\absu{\lambda}{x}{\absu{\lambda}{xs}{\absu{\Lambda}{eq}{suc\
    % (len\ \mhyph n\ xs)}}}}}
  \end{array})
\]

\noindent In general, the generated name for $I'$ and $x_{\text{to}}$ that users
will write in Cedilleum programs will be of the form ``$I\texttt{/}x_{\text{rec}}$''
and ``$\texttt{from}I\texttt{/}x_{\text{rec}}$''.

For a pattern construct ($\mu$ or $\mu'$) in the AST to be well-formed, it must satisfy the
following conditions (each of which is, again, explained in more detail in
Subsections \ref{ssec:pattern-valid-elim}, \ref{ssec:pattern-wf-pat}, and
\ref{ssec:patern-abstracted-gen}):

\begin{itemize}
\item The motive $P$ must be well-kinded
\item $P$ must be a legal motive to be used in eliminating the inductive type
  $I$ of the scrutinee $t$
\item Each branch $t_i$ must have the type expected given the constructor $c_i
  \in \Sigma$ and the motive $P$.
\end{itemize}

\subsection{Auxiliary Definitions}
\label{ssec:inductive-aux-defs}

\paragraph{Contexts}
To ease the notational burden, we will introduce some conventions for writing
contexts within terms and types.

\begin{itemize}
\item We write $\lambda\,\Gamma$, $\Lambda\,\Gamma$, $\forall\,\Gamma$, and
  $\Pi\,\Gamma$ to indicate some form of abstraction over each variable in
  $\Gamma$. For example, if $\Gamma = \ann{x_1}{T_1},\ann{x_2}{T_2}$ then
  $\absu{\lambda}{\Gamma}{t} =
  \abs{\lambda}{x_1}{T_1}{\abs{\lambda}{x_2}{T_2}{t}}$. Additionally, we
  will also write $\piforall\,\Gamma$ to indicate an arbitrary mixture of $\Pi$
  and $\forall$ quantified variables. Note that \textit{if $\piforall\,\Gamma$
  occurs multiple times within a definition or inference rule}, the intended
  interpretation is that \textit{all occurrences have the same mixture of $\Pi$
    and $\forall$ quantifiers}.
\item $\lenc{\Gamma}$ denotes the length of $\Gamma$ (the number of variables it
  binds)
\item We write $s\ \Gamma$ to indicate the sequence of variable arguments in
  $\Gamma$ given as arguments to $s$. Implicit in this notation is the removal
  of typing annotations from the variables $\Gamma$ when these variables are
  given as arguments to $s$.

  Since in Cedilleum there are three flavors of applications (to a type, to an
  erased term, and to an unerased term), we will only us this notion when the type
  or kind of $s$ is known, which is sufficient to disambiguate the flavor of
  application intended for each particular binder in $\Gamma$. For example,
  if $s$ has type
  $\abs{\forall}{X}{‚òÖ}{\abs{\forall}{x}{X}{\abs{\Pi}{x'}{X}{X}}}$ and $\Gamma =
  \ann{X}{‚òÖ},\ann{x}{X},\ann{x'}{X}$ then $s\ \Gamma = s\ \cdot X\ \mhyph x\ x'$
\item $\Delta$ and $\Delta'$ are notations we will use
  for a specially designated contexts associating type variables with both global
  ``concrete'' and local ``abstracted'' inductive data-type declarations.
  The purpose of this latter sort of declaration is to enable type-guided
  termination of definitions using fixpoints (see Section \ref{ssec:typing-rules}) For example, given
  just the (global) data type declaration of $Vec$, we would have $\Delta(Vec) =
  \indast{\text{C}}{1}{\Gamma_{Vec}}{\Sigma}$, where $\Gamma_{Vec} = \ann{Vec}{‚òÖ ‚ûî Nat ‚ûî
    ‚òÖ}$ and  $\Sigma$ binds data constructors $vnil$ and $vcons$ to the
  appropriate types.
\end{itemize}

\paragraph{$p$-arity}

A kind $K$ is a $p$-arity if it can be written as $\absu{\Pi}{\Gamma}{K'}$ for
some $\Gamma$ and $K'$, where $\lenc{\Gamma} = p$. For an inductive definition
$\indast{M}{p}{\Gamma_I}{\Sigma}$, requiring that the kind $\Gamma_{I}(I)$ is a $p$-arity
of ‚òÖ ensures that $I$ \textit{really does have} $p$ parameters.

\paragraph{Types of Constructors}
% TODO: if you look at the `generation of abstracted inductive definitions', it
% uses a different format for the types associated with the constructors in
% \Sigma -- that is the \piforall notation. This section probably should be
% reworked to that end.
$T$ is a \textit{type of a constructor of $I$} iff
\begin{itemize}
\item it is $I\ s_1 ... s_n$
\item it can be written as $\abs{\forall}{s}{C}{T}$ or $\abs{\Pi}{s}{C}{T}$,
  where (in either case) $T$ is a type of a constructor of $I$
\end{itemize}

\paragraph{Positivity condition}
The positivity condition is defined in two parts: the positivity condition of
a type $T$ of a constructor of $I$, and the positive occurence of $I$ in $T$.
We say that a type $T$ of a constructor of $I$ satisfies the positivity condition
when

\begin{itemize}
\item $T$ is $I\ s_1... s_n$ and $I$ does not occur anywhere in $s_1...s_n$
\item $T$ is $\abs{\forall}{s}{C}{T'}$ or $\abs{\Pi}{s}{C}{T'}$, $T'$ satisfies
  the positivity condition for $I$, and $I$ occurs \textit{only} positively in $C$ 
\end{itemize}

\noindent We say that $I$ occurs only positively in $T$ when
\begin{itemize}
\item $I$ does not occur in $T$
\item $T$ is of the form $I\ s_1 ... s_n$ and $I$ does not occur in $s_1 ...
  s_n$
\item $T$ is of the form $\abs{\forall}{s}{C}{T'}$ or $\abs{\Pi}{s}{C}{T'}$, $I$
  occurs only positively in $T'$, and $I$ \textit{does not} occur positively in $C$
\end{itemize}

\subsection{Well-formed inductive definitions}
\label{ssec:inductive-wf-def}

Let $\Gamma_{\text{P}},\Gamma_I,$ and $\Sigma$ be contexts such that $\Gamma_I$
associates a single type-variable $I$ to kind $\absu{\Pi}{\Gamma_{\text{p}}}{K}$ and
$\Sigma$ associates term variables $c_1 ... c_n$ with corresponding types
$\absu{\forall}{\Gamma_{\text{P}}}{T_{1}},...\absu{\forall}{\Gamma_{\text{P}}}{T_{n}}$.
Then the rule given in Figure \ref{fig:inductive-intro} states when an inductive
datatype definition may be introduced, provided that the following side
conditions hold:

\begin{figure}[h]
  \caption{Introduction of inductive datatype}
  \label{fig:inductive-intro}
  \[
    \infer
    { \indast{M}{p}{\Gamma_I}{\Sigma}\ wf}
    { \emptyset \vdash \Gamma_I(I) : \square
      \quad \lenc{\Gamma_P} = p
      \quad (\Gamma_I,\Gamma_P \vdash T_i : ‚òÖ)_{i=1..n}
    }
  \]
\end{figure}

\begin{itemize}
  \item Names $I$ and $c_1..c_n$ are distinct from any other inductive datatype
    type or constructor names, and distinct amongst themselves
  \item Each of $T_1..T_n$ is a type of constructor of $I$ which satisfies the
    positivity condition for $I$. Furthmore, each occurence of $I$ in $T_i$ is
    one which is applied to the parameters $\Gamma_P$.
  \item Identifiers $I$, $c_1,...,c_n$ are fresh w.r.t the global context, and
    do not overlap with each other nor any identifiers in $\Gamma_P$.
\end{itemize}

When an inductive data-type has been defined using the $defDataType$ production,
it is understood that this always a concrete inductive type, and it (implicitly)
adds to a global typing context the variable bindings in $\Gamma_I$ and
$\Sigma$. Similarly, when checking that the kind $\Gamma_I(I)$ and type $T_i$
are well-sorted and well-kinded, we assume an (implicit) global context of
previous definitions.

\subsection{Valid Elimination Kind}
\label{ssec:pattern-valid-elim}

\begin{figure}[h]
  \caption{Valid elimination kinds}
  \label{fig:valid-elim-kind}
  \[
    \begin{array}{ccc}
      \infer
      { \llbracket T : ‚òÖ\ |\ T \to ‚òÖ \rrbracket }
      { }
      & \infer
        { \llbracket T : \abs{\Pi}{s}{C}{K}\ |\ \abs{\Pi}{s}{C}{K'} \rrbracket}
        { \llbracket T\ s : K\ |\ K' \rrbracket }
    \end{array}
  \]
\end{figure}

When type-checking a pattern match (either $\mu$ or $\mu'$), we need to know
that the given motive $P$ has a kind $K$ for which elimination of a term with
some inductive data-type $I$ is permissible. We write this judgment as
$\llbracket \ann{T}{K'} | K \rrbracket$, which should be read ``the type $T$ of kind $K'$ can
be eliminated through pattern-matching with a motive of kind $K$''. This
judgment is defined by the simple rules in Figure \ref{fig:valid-elim-kind}. For
example, a valid elimination kind for the indexed type family $Vec\ \cdot X$
(which has kind $\abs{\Pi}{n}{Nat}{‚òÖ}$) is $\abs{\Pi}{n}{Nat}{\abs{\Pi}{x}{Vec\
    \cdot X\ n}{‚òÖ}}$

\subsection{Valid Branch Type}

Another piece of kit we need is a way to ensure that, in a pattern-matching
expression, a particular branch has the correct type given a particular
constructor of an inductive data-type and a motive. We write $\llbrace c : T
\rrbrace^P_I$ to indicate the type corresponding to the (possibly partially
applied) constructor $c$ of $I$ and its type $T$. We
abbreviate this notation to $\llbrace c \rrbrace^P$ when the inductive type
variable $I$, and the type $T$ of $c$, is known from the (meta-language) context.

\[
  \begin{array}{rcl}
    \llbrace c : I\ \vars{T}\ \vars{s} \rrbrace^P_I
    & = & P\ \vars{s}\ c
    \\ \llbrace c : \abs{\forall}{x}{T'}{T} \rrbrace^P_I
    & = & \abs{\forall}{x}{T'}{\llbrace c\ \mhyph x : T \rrbrace^P_I }
    \\ \llbrace c : \abs{\forall}{x}{K}{T} \rrbrace^P_I
    & = & \abs{\forall}{x}{K}{\llbrace c\ \cdot x : T \rrbrace^P_I }
    \\ \llbrace c : \abs{\Pi}{x}{T'}{T} \rrbrace^P_I
    & = & \abs{\Pi}{x}{T'}{\llbrace c\ x : T \rrbrace^P_I }
  \end{array}
\]

\noindent where we leave implicit the book-keeping required to separate the
parameters $\vars{T}$ from the indicies $\vars{s}$.

The biggest difference bewteen this definition and the similar one found in the
Coq documentation is that types can have implicit and explicit quantifiers, so
we must make sure that the types of branches have implicit / explicit
quantifiers (and the subjects $c$ have applications for types, implicit terms, and
explicit terms), corresponding to those of the arguments to the data constructor
for the pattern for the branch.

\subsection{Well-formed Patterns}
\label{ssec:pattern-wf-pat}

\begin{figure}[h]
  \caption{Well-formedness of a pattern}
  \label{fig:wf-pattern}
  \[
    \infer
    { \wfpat{\Gamma,\Delta}{\indast{M}{p}{\Gamma_I}{\Sigma}}{\vars{T}}{\mu'(t,P,t_{i=1..n})}
    }
    { \Gamma \vdash P : K
      \quad \Sigma = \ann{c_1}{\absu{\forall}{\Gamma_P}{T_1}}, ..., \ann{c_n}{\absu{\forall}{\Gamma_P}{T_n}}
      \quad \lenc{\vars{T}} = \lenc{\Gamma_p} = p
      \quad \llbracket I\ \vars{T}\, : \Gamma(I)\, |\, K \rrbracket
      \quad (\Gamma,\Delta \decchk t_i : \llbrace c_i\ \vars{T} \rrbrace^P)_{i=1..n}
    }
  \]
\end{figure}

% TODO 
Figure \ref{fig:wf-pattern} gives the rule for checking that a pattern
$\mu'(t,P,t_{i=1..n})$ is well-formed. We check that the motive $P$ is
well-kinded at kind $K$, that the given parameters $\vars{T}$ match the expected
number $p$ from the inductive data-type declaration, that an inductive data-type
$I$ instantiated with the given parameters $\vars{T}$ can be eliminated to a
type of kind $K$, and that the given branches $t_i$ account for each of the
constructors $c_i$ of $\Sigma$ and have the required branch type $\llbrace c_i\
\vars{T} \rrbrace^P$ under the given local context $\Gamma$ and context of
inductive data-type declarations $\Delta$.

\subsection{Generation of Abstracted Inductive Definitions}
\label{ssec:patern-abstracted-gen}

Cedilleum supports \textit{histomorphic} recursion (that is, having access to
all previous recursive values) where termination is ensured
through typing. In order to make this possible, we need a mechanism for tracking
the global definitions of \textit{concrete} inductive data types as well the
locally-introduced \textit{abstract} inductive data type representing the
recursive occurences suitable for a fixpoint function to be called on.

If $I$ is an inductive type such that $\Delta(I) =
\indast{\text{C}}{p}{\Gamma_I}{\Sigma}$ and $I'$ is a fresh type variable, then we
define function $Hist(\Delta,I,\vars{T},I')$ producing an abstracted (well-formed)
inductive definition $\indast{\text{A}}{0}{\Gamma_{I'}}{\Sigma'}$, where

\begin{itemize}
\item $\Gamma_{I'}(I') = \absu{\forall}{\Gamma_D}{‚òÖ}$ if $\Gamma_{I}(I) =
  \absu{\forall}{\Gamma_{P}}{\absu{\forall}{\Gamma_D}{‚òÖ}}$ (and $\lenc{\Gamma_P}
  = \lenc{\vars{T}} = p$)

  That is, the kind of $I'$ is the same as the kind of $I\ \vars{T}$
\item $\Sigma' = \ann{c'_1}{\absu{\forall}{\Gamma_D}
    { \absu{\piforall}{\Gamma_{A'_1}}{I'\ \Gamma_D} }},...,
  \ann{c'_n}{\absu{\forall}{\Gamma_D}
    { \absu{\piforall}{\Gamma_{A'_n}}{I\ \vars{T}\ \Gamma_D} }}$,

  when each of the concrete constructors $c_i$ in $\Sigma$ are associated with
  type $\absu{\forall}{\Gamma_P}{
    \absu{\forall}{\Gamma_D}{ \absu{\piforall}{\Gamma_{A_i}}{I\ \Gamma_P\
        \Gamma_D} } }$ and each $\Gamma_{A'_i} =
  [\absu{\lambda}{\Gamma_P}{I'}/I,\vars{T}/\Gamma_P]\Gamma_{A_i}$.

  That is, trasforming the concrete constructors of the inductive datatype $I$
  to ``abstracted'' constructors involves replacing each recursive occurrence of
  $I\ \Gamma_P$ with the fresh type variable $I$, and instantiating each of the
  parameters $\Gamma_P$ with $\vars{T}$.
\end{itemize}

Users of Cedilleum will see ``punning'' of the concrete constructors $c_i$ and
abstracted constructors $c'_i$. In particular, when using fix-point pattern
matching branch labels will be written with the constructors for the concrete
inductive data-type, and the expected type of a branch given by the motive will
pretty-print using the concrete constructors. In the inference rules, however,
we will take more care to distinguish the abstract constructors (see Subsection
\ref{ssec:typing-rules}).

\subsection{Typing Rules}
\label{ssec:typing-rules}

\begin{figure}[h]
  \caption{Use of an inductive datatype $\indast{M}{p}{\Gamma_I}{\Sigma}$}
  \label{fig:inductive-use}
  \[ \footnotesize
    \begin{array}{c}
      \infer
      { \Gamma,\Delta \decdir \mu'(t,P,t_{i=1..n}) : P\ \vars{s}\ t}
      { \Gamma \decsyn t : I\ \vars{T}\ \vars{s}
      \quad \wfpat{\Gamma,\Delta}{\Delta(I)}{\vars{T}}{\mu'(t,P,t_{i=1..n})}
      }
      \\ \\
      \\ \infer
      { \Gamma,\Delta \decdir \mu(x_{\text{rec}}, I',
      x_{\text{to}},t,P,t_{i=1..n}) : P\ \vars{s}\ t
      }
      {
      \begin{array}{c}
        \begin{array}{cccc}
          \Gamma \decsyn t : I\ \vars{T}\ \vars{s}
          & \Delta(I) = \indast{\text{C}}{p}{\Gamma_I}{\Sigma}
          & \Gamma_I(I) =
            \absu{\Pi}{\Gamma_P}{\absu{\Pi}{\Gamma_{\text{D}}}{‚òÖ}},\lenc{\Gamma_P}
            = p
          & Hist(\Delta,I,\vars{T},I') = \indast{\text{A}}{0}{\Gamma_{I'}}{\Sigma'}
        \end{array}
        \\ \\
        \begin{array}{cc}
          \Gamma' = \Gamma,\Gamma_{I'},
          \ann
           {x_{\text{to}}=\absu{\Lambda}{\Gamma_D}{\absu{\lambda}{x}{x}}}
           { \absu{\forall}{\Gamma_{\text{D}}}{I'\
            \Gamma_{\text{D}} \to I\ \vars{T}\
            \Gamma_{\text{D}}}},
          \ann{x_{\text{rec}}}{\absu{\forall}{\Gamma_{\text{D}}}{\abs{\Pi}{x}{I'\
          \Gamma_{\text{D}}}{P\ \Gamma_{\text{D}}\ (x_{\text{to}}\ \Gamma_D\ x)}
          }}
          & \Delta' = \Delta,Hist(\Delta,I,\vars{T},I')
        \end{array}
        \\ \\
        \begin{array}{cc}
          % P' = \absu{\lambda}{\Gamma_D}{\abs{\lambda}{x}{I\ \vars{T}\ \Gamma_D}{P\ 
          % \Gamma_D\ x} }
          \wfpat{\Gamma',\Delta'}{\Delta'(I')}{\varnothing}{\mu'(t,P,t_{i=1..n})}
        \end{array}
      \end{array}
      }
    \end{array}
  \]
\end{figure}

The first rule of Figure \ref{fig:inductive-use} is for typing simple pattern
matching with $\mu'$. We need to know that the scrutinee $t$ is well-typed at
some inductive type $I\ \vars{T}\ \vars{s}$, where $\vars{T}$ represents the
parameters and $\vars{s}$ the indicies. Then we defer to the judgment
$WF\mhyph\!Pat$ to ensure that this pattern-matching expression is a valid
elimination of $t$ to type $P$.

The second rule is for typing pattern-matching with fix-points, and is
significantly more involved. As above we check the scrutinee $t$ has some
inductive type $I\ \vars{T}\ \vars{s}$. We confirm that $I$ is a
\textit{concrete} inductive data-type by looking up its definition in $\Delta$,
and then generate the abstracted definition $Hist(\Delta,I,\vars{T},I')$ for some fresh
$I'$. We then add to the local typing context $\Gamma_{I'}$ (the new inductive
type $I'$ with its associated kind) and two new variables $x_{\text{to}}$ and
$x_{\text{rec}}$.

\begin{itemize}
\item $x_{\text{to}}$ is the \textit{revealer}. It casts a term of an abstracted inductive
  data-type $I'\ \Gamma_D$ to the concrete type $I\ \vars{T}\ \Gamma_D$.
  Crucially, it is an \textit{identity} cast (the implicit quantification
  $\Lambda \Gamma_D$ disappears after erasure). The intuition why this should be
  the case is that the abstracted type $I'$ only serves to mark the recursive
  occurrences of $I$ during pattern-matching to guarantee termination.
\item $x_{\text{rec}}$ is the \textit{recursor} (or the inductive hypothesis).
  Its result type $P'\ \Gamma_D\ x$ utilizes $x_{\text{to}}$ in $P'$ to be
  well-typed, as the $x$ in this expression has type $I'\ \Gamma_D$, but $P$
  expects an $I\ \vars{T}\ \Gamma_D$. Because $x_{\text{to}}$ erases to the identity, uses of the
  $x_{\text{rec}}$ will produce expressions whose types will not interfere with
  producing the needed result for a given branch (see the extended example --
  TODO).
\end{itemize}

\noindent With these definitions, we finish the rule by checking that the
pattern is well-formed using the augmented local context $\Gamma'$ and context
of inductive data-type definitions $\Delta'$.

\bibliographystyle{alpha}
\bibliography{spec}

\end{document}
