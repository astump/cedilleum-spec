\documentclass{article}


% \usepackage{todonotes}
\usepackage{amsmath,amssymb,amsthm}
%\usepackage{unicode-math}
\usepackage{url}
\usepackage{fullpage}

\usepackage{subcaption}
\usepackage{cedilleverbatim}
\usepackage{proof}

\usepackage{stmaryrd}
\usepackage{soul}
% \usepackage{unicode-math}

\DeclareUnicodeCharacter{03BC}{\ensuremath{\mu}}
\DeclareUnicodeCharacter{0393}{\ensuremath{\Gamma}}
\DeclareUnicodeCharacter{21A6}{\ensuremath{\to}}
\DeclareUnicodeCharacter{25CF}{\ensuremath{\bullet}}
\DeclareUnicodeCharacter{1D48C}{\ensuremath{\kappa}}
\DeclareUnicodeCharacter{1D62}{\ensuremath{_{\texttt{D}}}} % maps _i to _d
\DeclareUnicodeCharacter{209A}{\ensuremath{_{\texttt{p}}}}
\DeclareUnicodeCharacter{2C7C}{\ensuremath{_{\texttt{j}}}} % maps _J to _j
\DeclareUnicodeCharacter{2096}{\ensuremath{_{\texttt{k}}}} % maps _J to _j
\DeclareUnicodeCharacter{1D3F}{\ensuremath{^{\texttt{R}}}}
\DeclareUnicodeCharacter{208B}{\ensuremath{_{-}}}
\DeclareUnicodeCharacter{208C}{\ensuremath{_{=}}}
\DeclareUnicodeCharacter{2098}{\ensuremath{_{m}}}
\DeclareUnicodeCharacter{2099}{\ensuremath{_{n}}}
\DeclareUnicodeCharacter{1D64}{\ensuremath{_{\texttt{y}}}}
\DeclareUnicodeCharacter{2093}{\ensuremath{_{x}}}
\DeclareUnicodeCharacter{22EF}{\ensuremath{_{..}}}
\DeclareUnicodeCharacter{2080}{\ensuremath{_0}}
\DeclareUnicodeCharacter{2083}{\ensuremath{_3}}
\DeclareUnicodeCharacter{00B9}{\ensuremath{^1}}
\DeclareUnicodeCharacter{00B2}{\ensuremath{^2}}
\DeclareUnicodeCharacter{20B8}{\ensuremath{\vars{\texttt{t}}}}
\DeclareUnicodeCharacter{015F}{\ensuremath{\vars{\texttt{c}}}}

% useful macros
\newcommand{\ann}[2]{#1\! : \! #2}
\newcommand{\abs}[4]{{#1}\, #2\! : \! #3.\, #4}
\newcommand{\absu}[3]{{#1}\, #2.\, #3}
\mathchardef\mhyph="2D % Define a "math hyphen"
\newcommand{\indast}[4]{\texttt{Ind}_{#1} [#2] (#3 := #4)}
\newcommand{\lowerc}[1]{\lfloor {#1} \rfloor}
\newcommand{\lenc}[1]{\|#1\|}
\newcommand{\vars}[1]{{\overline{#1}}}

% - type inference
\newcommand{\decdir}{\vdash_{\delta}}
\newcommand{\decsyn}{\vdash_{\Uparrow}}
\newcommand{\decchk}{\vdash_{\Downarrow}}

% - inductive
\newcommand{\mufix}[3]{Œº\ #1\ .\ #2\ \textbf{\{} #3 \textbf{\}}}
\newcommand{\mumat}[2]{Œº'\ #1\ \textbf{\{}#2\textbf{\}}}
\newcommand{\wfpat}[4]{WF\!\mhyph\!Pat(#1,#2,#3,#4)}
\newcommand{\llbrace}{\{\!\{}
\newcommand{\rrbrace}{\}\!\}}
\newcommand{\piforall}{^{\Pi}_{\forall}}
\newcommand{\lamLam}{^{\lambda}_{\Lambda}}
\DeclareUnicodeCharacter{03A8}{\ensuremath{\piforall}} % maps Œ® to \piforall
\DeclareUnicodeCharacter{03C8}{\ensuremath{\lamLam}}   % maps œà to \lamLam
\newcommand{\reduce}{\ensuremath{\rightsquigarrow}}

\begin{document}

\title{The Cedilleum Language Specification \\ \large Syntax, Typing, Reduction,
  and Elaboration }

\author{Christopher Jenkins}

\maketitle

\section{Introduction}
\label{sec:intro}
This document describes \textit{Cedilleum}, a general-purpose dependently typed
programming language with inductive datatypes. Unlike most languages of this
description, the underlying theory of Cedilleum is \textit{not} the Calculus of
Inductive Constructions (CIC)\cite{Pa15_Intro-CIC}. Instead, Cedilleum is
designed so that it may easily be translated to \textit{Cedille Core} -- a
compact core theory in which induction is derivable for lambda-encoded datatypes
-- while still providing high-level features like pattern-matching and recursive
definitions. That said, the formal specification of Cedilleum as a
self-contained language has a lot in common with CIC -- see in particular
Section 8 of \cite{In18_Coq-Docs}, which served as the basic template for much
of this document's formal development.

\subsection{Data-type Declarations}
Before diving into the details, let us take a bird's-eye view of the language
by showing some simple example data-type definitions and functions over them.

\begin{figure}[h]
\begin{verbatim}
-- Non-recursive
data Bool: ‚òÖ =
  | tt: Bool
  | ff: Bool
.
-- Recursive
data Nat: ‚òÖ = 
  | zero: Nat
  | succ: Nat ‚ûî Nat
.
-- Recursive, parameterized, indexed
data Vec (A: ‚òÖ): Nat ‚ûî ‚òÖ =
  | vnil : Vec zero
  | vcons: ‚àÄ n: Nat. A ‚ûî Vec n ‚ûî Vec (succ n)
.
\end{verbatim}
  \caption{Definition of natural numbers and length-indexed lists}
  \label{fig:ex-data-decl}
\end{figure}
Figure \ref{fig:ex-data-decl} shows some definitions of inductive datatypes, and
modulo differences in syntax should seem straightforward to programmers used
to languages like Agda, Idris, or Coq. Some key differences are:

\begin{itemize}
\item In constructor type signatures, recursive occurrences of the inductive
  data-type being defined (such as in \texttt{suc : \underline{Nat} ‚ûî Nat}) must
  be positive, \textit{but not strictly positive}.
\item In parameterized types (like \texttt{Vec} with parameter \texttt{(A: ‚òÖ)})
  occurrences of the inductive type being defined are not written applied to
  its parameters.
  
  For example, the constructor declaration \texttt{vnil : Vec zero} results in
  the term \texttt{vnil} having type \\ \texttt{‚àÄ A: ‚òÖ. Vec ¬∑A zero} (with \texttt{¬∑}
  denoting type application)
\item In the constructor declaration \texttt{vcons : ‚àÄ n: Nat. A ‚ûî Vec n ‚ûî Vec
    (succ n)}, the argument \texttt{n} is \textit{computationally irrelevant}
  (also called \textit{erased}). This is because it is introduced by the
  irrelevant dependent function former \texttt{‚àÄ}, as opposed to the relevant
  function former \texttt{Œ†}. More will be said of this when we discuss the type
  system of Cedilleum, but for now it suffices to say that implicit
  quantification comes from the \textit{Implicit Calculus of
    Constructions}\cite{Mi01_ICC}.
\end{itemize}

\subsection{Function Definitions}
\begin{figure}[h]
\begin{verbatim}
-- Non-recursive
ite : ‚àÄ X: ‚òÖ. Bool ‚ûî X ‚ûî X ‚ûî X
  = Œõ X. Œª b. Œª then. Œª else. Œº' b {
      | tt ‚ûî then
      | ff ‚ûî else
      }.
-- Recursive
add : Nat ‚ûî Nat ‚ûî Nat
  = Œª n. Œª m.
      Œº rec. n @(Œª x: Nat. Nat) {
      | zero   ‚ûî m
      | succ p ‚ûî succ (rec p)
      }.
\end{verbatim}
  \caption{Functions over inductive datatypes}
  \label{fig:ex-data-fun}
\end{figure}

Figure \ref{fig:ex-data-fun} shows functions defined over inductive datatypes
using pattern matching and recursion. The first difference to note between the
definitions is that \texttt{ite} performs ``mere''
pattern matching on its argument by using \texttt{Œº'}, whereas \texttt{add}
uses \texttt{Œº} which provides combined pattern-matching and fix-point
recursion. In \texttt{add}, \texttt{Œº} binds \texttt{rec} as the name of the
fixpoint function for recursion on \texttt{n}. From this alone the reader might
expect that \texttt{Œº'} is merely syntactic sugar for the more verbose
\texttt{Œº} but without recursion. Actually the difference is a bit more subtle
that this, as we will see below in Section \ref{sec:hist-rec}

The first major departure of Cedilleum from other languages with inductive
datatypes can be seen in the type of \texttt{rec}. The type that the reader
might expect it to have is \verb;Œ† x: Nat. Nat; (corresponding to the motive
\verb;(Œª x: Nat.Nat);), but in Cedilleum, its type is \verb;rec/type ‚ûî Nat;
(where we read \texttt{rec/type} as a single identifier) and by extension for
the expression \texttt{rec p} to be well-typed, the variable \texttt{p} bound in
the pattern \texttt{succ p} must have type \texttt{rec/type}. The name
\texttt{rec/type} is lexically scoped to the body of the Œº-expression (delimited
by curly braces \texttt{\{...\}}) and is
automatically generated by Cedilleum by using the name of the recursive
function given by the user (here this is \texttt{rec}) bound by Œº. Why introduce this new type? For recursive
functions in Cedilleum, \textit{termination is guaranteed by the type system}
and not by a separate syntactic check that recursive calls are made on
structurally smaller arguments. The type \texttt{rec/type} indicates the types
of those terms which \texttt{rec} may legally take as arguments. These
``recursive-occurence'' types appear in the types of sub-data (such
as \texttt{p} in the example) in the constructor patterns of the case branches
introduced by Œº, replacing all
occurences of the inductive type itself.
% \footnotetext{More precisely, the type of every
% variable bound by a constructor pattern of a case branch introduced by
% \texttt{Œº} has all occurences of $\texttt{I}\ \vars{P}$ replaced by
% \texttt{I/fixpoint-name}, where $\vars{P}$ are the parameters.}

% The type \texttt{Nat/add-rec} (and any such type generated by use of
% \texttt{Œº}) comes with some restrictions, which will be made more precise
% further on in the document. Informally, such terms cannot themselves be given to
% \texttt{Œº} directly as in `\verb;Œº add-rec2. r; ...' and despite the deceptive
% case label `\verb;| suc r ‚Ü¶ ;...' \texttt{r} cannot be given directly to
% constructor \texttt{succ}, as \texttt{Nat} and \texttt{Nat/add-rec} are distinct
% types. However, even so these two types \textit{are} related to each other, most
% notably in the way they are treated by \texttt{Œº'} -- terms of type \texttt{Nat}
% and \texttt{Nat/add-rec} alike support mere pattern matching through \texttt{Œº'}.

\begin{figure}[h]
\begin{verbatim}
-- Recursive, parameterized, indexed
vappend : ‚àÄ A: ‚òÖ. ‚àÄ m: Nat. ‚àÄ n: Nat. Vec ¬∑A m ‚ûî Vec ¬∑A n ‚ûî Vec ¬∑A (add m n)
  = Œõ A. Œõ m. Œõ n. Œª xs. Œª ys.
      Œº rec. xs @(Œª i: Nat. Œª zs: Vec ¬∑A i. Vec ¬∑A (add i n)) {
      | vnil            ‚ûî ys
      | vcons -m' x xs' ‚ûî [ zs = rec -m' xs' ] - vcons -(add m' n) x zs
      }.
\end{verbatim}
  \caption{Dependent functions over inductive datatypes}
  \label{fig:ex-data-dep}
\end{figure}

Figure \ref{fig:ex-data-dep} shows the classic dependent function
\texttt{vappend} over \texttt{Vec}, the type of length-indexed lists. Like
\texttt{add}, it is defined by fixpoint recursion, here over the argument
\texttt{xs}. Here the fixpoint function \texttt{rec} has type
\texttt{‚àÄ i: Nat. Œ† zs: rec/type i. Vec ¬∑A (add i n)}, where the recursive
occurence type has kind \texttt{Nat ‚ûî ‚òÖ}. Note again the missing parameter
\texttt{A} in the type \texttt{rec/type i} -- this is not a typo, but rather an
indication that \texttt{A} is ``baked-in'' to the type \texttt{rec/type}. Aside
from this the two cases of \texttt{vappend} are mostly straightforward: in the
\texttt{vnil} branch the expected type is \verb;Vec ¬∑A (add zero n); which
converts to \verb;Vec ¬∑A n;, so \texttt{ys} suffices; in the \texttt{vcons}
branch we bind subdata \verb;m': Nat;, \verb;x: A;, and \verb;xs': rec/type m';,
with \verb;-m'; indicating that \verb;m'; is bound \textit{irrelevantly}, then
we make a local biding \texttt{zs} by invoking recursive function \texttt{rec} on
\texttt{m'} and \texttt{xs'} (where here \texttt{-m'} indicates \texttt{m'}
is an irrelevant \textit{argument} to \texttt{rec}) before producing a result
whose type is convertible with the expected \verb;Vec ¬∑A (add (suc m') n);.

\subsection{Course-of-Value Recursion}

We now study Cedilleum's recursive-occurence types more closely. Languages
with inductive datatypes and recursive function definitions that also wish to
have their type systems interpreted as sound logics must address the issue of
\textit{termination}, because the principle of general recursion \texttt{‚àÄ A: ‚òÖ.
(A ‚ûî A) ‚ûî A} allows one to inhabit every type, the definition of unsoundness! To
that end, most such languages perform some terminiation check separate from type
checking to make sure that arguments to recursive calls are
structurally smaller than previous invocations, ensuring that eventually a base case is
reached. This check is necessarily conservative (i.e. it will not accept all
terminating functions), and the classic example of a function that is not
``obviously'' terminating is division on natural numbers by iterated
subtraction. Intuitively, we understand that subtracting \texttt{n} from
\texttt{m} never produces a number larger than \texttt{m} -- but it can be
tricky to explain this to the termination checker! One advantage that
Cedilleum's type-guided termination checking has is that it allows for a very
natural definition of division as iterated subtraction that is ``obviously''
terminating.

\label{sec:hist-rec}
\begin{figure}[h]
\begin{verbatim}
pred' : ‚àÄ R: ‚òÖ. Nat/Mu ¬∑R ‚ûæ R ‚ûî R
  = Œõ R. Œõ muWit. Œª r. Œº'<muWit> r {| zero ‚ûî r | succ r' ‚ûî r'}.

pred : Nat ‚ûî Nat = pred' -Nat/mu .

minus' : ‚àÄ R: ‚òÖ. Nat/Mu ¬∑R ‚ûæ R ‚ûî Nat ‚ûî R
  = Œõ R. Œõ muWit. Œª m. Œª n. Œº rec. n @(Œª _: Nat. R) {
  | zero   ‚ûî m
  | succ n' ‚ûî pred' -muWit (rec n')
  }.

minus : Nat ‚ûî Nat ‚ûî Nat = minus' -Nat/Rec .

lt : Nat ‚ûî Nat ‚ûî Bool
  = Œª m. Œª n. Œº' (minus m n) {
  | zero   ‚ûî ff
  | succ _ ‚ûî tt
  }.

divide : Nat ‚ûî Nat ‚ûî Nat
  = Œª n. Œª d. Œº rec. n @(Œª _: Nat. Nat) {
  | zero   ‚ûî zero
  | succ n' ‚ûî succ (rec (minus' -rec/mu n' (pred d)))
  }.
\end{verbatim}
  \caption{Histomorphic recursion and division}
  \label{fig:ex-data-div}
\end{figure}

The definition of division is given in Figure \ref{fig:ex-data-div}. Our first
definition, \texttt{pred'}, is crucial for defining \texttt{divide} further
below. The type \texttt{Nat/Mu ¬∑R} in its type signature is the type of
\textit{witnesses} that terms of type \texttt{R} can be pattern-matched (using Œº')
like if they had type \texttt{Nat}; in the definition of \texttt{pred'}, this witness
is given name \texttt{muWit}. All such witnesses are introduced in only one of
two ways: once \textit{globally} for each defined data-type (like \texttt{Nat}
itself -- in the definition of \texttt{pred} term \texttt{Nat/mu} has type
\texttt{Nat/Mu ¬∑Nat}; and \textit{locally} for each recursive-occurence type
introduce by Œº (in the body of \texttt{divide}, term \texttt{rec/mu} has type
\texttt{Nat/Mu ¬∑rec/type}). In the definition of \texttt{pred'}, the notation
\texttt{Œº'<muWit>} indicates that the witness \texttt{muWit} is given explicitly
to enable (mere) pattern-matching on argument \texttt{r}. After this, the
definition of \texttt{pred} is easy -- it is an instance of \texttt{pred'} where
\texttt{R} is specialized to \texttt{Nat} itself with evidence \texttt{Nat/mu}.

Next we define \texttt{minus'}. One intuition for the type signature of
\texttt{minus'} (and \texttt{pred'} before it) is that it says ``this function
will never increase the size of its \texttt{R} argument''. That is to say, to
return a term of type \texttt{R}, \texttt{minus'} can only return its argument
or some sub-data produced by pattern-matching. In
\texttt{pred'} this is done only once; in \texttt{minus'} it is done \texttt{n}
times by recursion on subtrahend \texttt{n} by invoking \texttt{pred'} each time.

Finally, we turn to the definition of \texttt{divide} itself. At a high level,
we recurse on dividend \texttt{n}, and in the \texttt{zero} case simply return
\texttt{zero}. In the successor case, we subtract the (predecessor of) the
divisor from the (predecessor of) the dividend, call \texttt{rec} on the result,
and then add one with \texttt{succ}. We must use \texttt{minus'} to perform
subtraction so that the call to \texttt{rec} is well-typed; note how this 
prevents the user from writing \texttt{rec (minus (succ n') d)}, which if
typeable would diverge when the divisor \texttt{d} is \texttt{zero}.

\subsection{Subtyping and Coercions}
\label{sec:subtyping-coercion}
\begin{figure}[h]
\begin{verbatim}
mult : Nat ‚ûî Nat ‚ûî Nat
  = Œª m. Œª n. Œº rec. m {
    | zero    ‚ûî zero
    | succ m' ‚ûî add n (rec m')
  }.

fact1 : Nat ‚ûî Nat
  = Œª n. Œº rec. m {
    | zero    ‚ûî succ zero
    | succ n' ‚ûî mult (succ (Nat/cast -rec/mu n')) (rec n')
  }.

NatCast-id : {Nat/cast ‚âÉ Œª x. x} = Œ≤.

fact2 : Nat ‚ûî Nat
  = Œª n. Œº rec. m {
    | zero    ‚ûî succ zero
    | succ n' ‚ûî mult (succ n') (rec n')
  }.
\end{verbatim}
  \caption{Factorial with explicit and implicit coercions}
  \label{fig:ex-data-fact}
\end{figure}

The reader may wonder at this point what other ways \texttt{Nat} and
recursive-occurence types like \texttt{rec/type} are related when there is a
witness of type \texttt{Nat/Mu ¬∑rec/type}. In addition to allowing the user to
pattern-match on terms of type \texttt{rec/type} as they would with \texttt{Nat}
and other data types, Cedilleum provides a way for users to coerce (with zero
runtime cost) such terms back to the original type. As a motivating example, consider
trying to implement the factorial function: in the constructor case \texttt{succ
n'}, we want to multiply the original number by the factorial (calculated via
recursion) of its predecessor. Two implementations of factorial are shown in
Figure \ref{fig:ex-data-fact}, showing how this conversion is done in Cedilleum.

In the first version, \texttt{fact1}, an explicit cast \texttt{Nat/cast -rec/mu n'} is used
to convert the \texttt{n'} of type \texttt{rec/type} to a \texttt{Nat};
\texttt{Nat/cast} is automatically generated from the definition of datatype
\texttt{Nat} and has type \texttt{‚àÄ R: ‚òÖ. Nat/Mu ¬∑R ‚ûæ R ‚ûî Nat}. Furthermore,
Cedilleum's built-in equality type recognizes that this term is equal to the
identity function (after erasure -- recall that \texttt{-rec/mu} inducates that
the witness is given as an irrelevant or erased argument to \texttt{Nat/cast}).

\subsection{Reasoning via Induction}
\label{sec:induction}
\begin{figure}[h]
\begin{verbatim}
add-zero-r : Œ† m: Nat. {add m zero ‚âÉ m}
  = Œª m. Œº ih. m @(Œª x: Nat. {add x zero ‚âÉ x}) {
         | zero   ‚ûî Œ≤
         | succ r ‚ûî œá {succ (add r zero) ‚âÉ succ r} - œÅ (ih r) - Œ≤
         } .
\end{verbatim}
  \caption{A proof via induction}
  \label{fig:ex-data-ind}
\end{figure}
Figure \ref{fig:ex-data-ind} shows a simple proof that \texttt{zero} is the
right identity of \texttt{add} using induction on \texttt{Nat}. In the base
case, pattern \texttt{zero} is substituted for \texttt{x} in the motive, and
the expected result type of the branch is \texttt{\{add zero zero ‚âÉ zero\}},
which is true by reflexivity (notated \texttt{Œ≤}) after conversion. In the step case, pattern
\texttt{succ r} is substituted in for \texttt{x} in the motive (which is
well-kinded in general thanks to subtyping, as \texttt{succ r} has type
\texttt{Nat}, even though \texttt{r} has type \texttt{ih/type}), and the
expected result type of the branch is \texttt{\{add (succ r) zero ‚âÉ succ r\}}.
Operator œá allows users to write type annotations, so the expected type converts
to the annotated type \texttt{\{succ (add r zero) ‚âÉ succ r\}}, which is then
rewritten using the inductive hypothesis \texttt{ih r}.

\subsection{Reduction Rules of Œº and Œº'}
In Section \ref{sec:induction} there was an omission regarding convertibility of
terms in the expected type of case branches. For example, the expected type
corresponding to the branch \texttt{succ r} in the definition of
\texttt{add-zero-r} above is \texttt{\{add (succ r) zero ‚âÉ succ r\}}. By
Œ≤-reduction alone, this reduces to
\begin{verbatim}
{ Œº rec. (succ r) {
  | zero ‚ûî zero
  | succ p ‚ûî succ (rec p)
  } ‚âÉ succ r
}
\end{verbatim}

To get the left-hand side of this equation to be convertible with \texttt{succ
  (add r zero)}, we need Œº-reduction rules. Œº-reduction is a combination of
fix-point unrolling and is typically called Œ¥-reduction for languages with
inductive data-types. Here, because the scrutinee is \texttt{succ r}, then
entire Œº-expression reduces to the body of the case-branch guarded by
\texttt{succ p}, with recursive function \texttt{rec} replaced by the entire
Œº-expression itself. Thus, the equation above reduces to
\begin{verbatim}
{ succ (Œº rec. r {
  | zero ‚ûî zero
  | succ p ‚ûî succ (rec p)
  }) ‚âÉ succ r
}
\end{verbatim}

\noindent where the left-hand side is now convertible with \texttt{succ (add r
  zero)}. Œº'-reduction works similarly, except there is no fixpoint to unroll.

\subsection{Non-strictly Positive Datatypes}
\label{sec:positive-data}
In the preceeding sections, we have that seen ``cast'' functions like
\texttt{Nat/ih} (in Figure \ref{fig:ex-data-ind}) show up in the the expected
type of a case branch, and also have noted already that Cedilleum allows for
positive but not strictly positive data type defintions. We now take a look at
how these two things interact.

\begin{figure}[h]
\begin{verbatim}
data PTree : ‚òÖ =
  | leaf : PTree
  | node : ((PTree ‚ûî Bool) ‚ûî PTree) ‚ûî PTree
.
PTreeSel : ‚òÖ = (PTree ‚ûî Bool) ‚ûî PTree.
indTree : ‚àÄ P: PTree ‚ûî ‚òÖ.
    P leaf ‚ûî (‚àÄ s: PTreeSel. (Œ† p: PTree ‚ûî Bool. P (s p)) ‚ûî P (node s))
    ‚ûî Œ† t: PTree. P t
  = Œõ P. Œª base. Œª step. Œª t. Œº ih. t @(Œª x: PTree. P x) {
      | leaf   ‚Ü¶ base
      | node s ‚Ü¶
        [ conv-p : (PTree ‚ûî Bool) ‚ûî PTree/ih ‚ûî Bool
          = Œª p. Œª r. p (fromPTree/ih r) ]
        - [ s' : PTreeSel = Œª p. fromPTree/ih (s (conv-p p)) ]
        - step -s' (Œª p. ih (s (conv-p p)))
      }.
\end{verbatim}
  \caption{A non-strictly positive infinitary tree}
  \label{fig:ptree}
\end{figure}

Figure \ref{fig:ptree} presents a definition of \texttt{PTree}, an infinitary
tree which is not strictly positive in the \texttt{node} constructor, and a
proof of induction for it using Œº. One intuition for what kind of terms inhabit
\texttt{PTree} is ``at a \texttt{node}, there must be some way of selecting one
\texttt{PTree} (of infinitely many) from some partition \texttt{PTree ‚ûî Bool}''.
The branch given by pattern \texttt{leaf} is the \texttt{base} case, requring a
proof of \texttt{P leaf} which we have by assumption. For the \texttt{step} case
given by the branch for pattern \texttt{node}, the expected type is the trickier
\texttt{P (node s')}, where \texttt{s'} is defined as above. Recall that in our
branch the constructor arguments have all recursive occurences of their
inductive type replaced with a special ``abstracted'' version. In the case of
\texttt{leaf}, the subdata \texttt{s} has type \texttt{(PTree/ih ‚ûî Bool) ‚ûî
PTree/ih}. The the naive expected branch type \texttt{P (node s)} given by
simply substituting the pattern in for the bound \texttt{x} given in the motive
is not well-kinded! To fix this we $\eta$-expand and cast using \texttt{fromPTree/ih}
as needed to produce the appropriate expected type.

Now we examine the body of the \texttt{node} branch itself more closely. First,
we need a way to convert any ``partition'' \texttt{p} of type \texttt{PTree ‚ûî
  Bool} to \texttt{PTree/ih ‚ûî Bool} so that it can operate over terms of the abstracted
type. With this we can do the same for our selector \texttt{s}, producing
\texttt{s'}. Finally, we invoke \texttt{step} so that we can have prove
\texttt{P (node s')} as desired. The second argument of \texttt{step} requires a
proof that \texttt{P (s' p)} holds for any \texttt{p}. To show this, we take the
assumed \texttt{p}, ``weaken'' it to work over the abstracted recursive types
with \texttt{conv-p}, and pass this to \texttt{s} (and not \texttt{s'}!) to
produce a value of type \texttt{PTree/ih} suitable for consumption by
\texttt{ih}, which has type \texttt{Œ† t: PTree/ih. P (fromPTree/ih t)}. Note
again that the proof we need to give here, \texttt{P (s' p)}, is convertible
with the proof \texttt{P (fromPTree/ih (s (conv-p p)))} that the call to
\texttt{ih} actually returns.

\section{Syntax}
\label{sec:syntax}

\paragraph{Identifiers}
\begin{figure}[h]
  \[
    \begin{array}{llll}
      id & &
      & \textnormal{identifiers for definitions}
      \\ u,c & &
      & \textnormal{term variables}
      \\ X & &
      & \textnormal{type variables}
      \\ ùíå & &
      & \textnormal{kind variables}
      \\ x & ::= & id\ |\ u\ |\ X\
      & \textnormal{non-kind variables}
      \\ y & ::= & x\ |\ ùíå & \text{all variables}
    \end{array}
  \]
  \caption{Identifiers}
  \label{fig:identifiers}
\end{figure}

We now turn to a more formal treatment of Cedilleum. Figure
\ref{fig:identifiers} gives the metavariables used in our grammar for
identifiers. We consider all identifiers as coming from two distinct lexical
``pools'' -- regular identifiers (consisting of identifiers $id$ given for
modules and definitions, term variables $u$, and type variables $X$) and kind
identifiers $\kappa$. In Cedilleum source files (as in the parent language
Cedille) kind variables should be literally prefixed with $\kappa$ -- the suffix
can be any string that would by itself be a legal non-kind identifier. For
example, \texttt{myDef} is a legal term / type variable and a legal name for a
definition, whereas \texttt{ùíåmyDeff} is only legal as a kind definition.

\paragraph{Untyped Terms}
\begin{figure}[h]
  \[
    \begin{array}{llll}
      f, p
      & ::= & u,v,c
      & \text{variables}
      \\ & & \absu{\textbf{Œª}}{u}{p}
      & \text{functions}
      \\ & & f\ p
      & \text{applications}
      \\ & & \mufix{u}{p}{pcase^*}
      & \text{fixed-point and pattern matching}
      \\ & & \mumat{p}{pcase^*}
      & \text{simple pattern matching}
      \\ \\ pcase
      & ::= & \textbf{\textbar}\ u\ u^* \mapsto f
    \end{array}
  \]
  \caption{Untyped terms}
  \label{fig:pure-terms}
\end{figure}

The grammar of pure (untyped) terms the untyped Œª-calculus augmented with a
primitives for combination fixed-point and pattern-matching definitions (and an
auxiliary pattern-matching construct).

\begin{figure}[h]
  \[
    \begin{array}{llll}
      % module stuff
      \\ mod
      & ::= & \textbf{module}\ id\ \textbf{.}\ imprt^*\ cmd^*\
      & \textnormal{module declarations}
      \\ imprt
      & ::= & \textbf{import}\ id\ \textbf{.}
      & \textnormal{module imports}
      \\ cmd
      & ::= & defTermOrType
      & \textnormal{definitions}
      \\ & & defDataType
      \\ & & defKind
      % definitions
      \\ 
      \\ defTermOrType
      & ::= & id\ checkType^?\ \textbf{=}\ t\ \textbf{.}
      & \textnormal{term definition}
      \\ & & id\ \textbf{:}\ K\ \textbf{=}\ T\ \textbf{.}
      & \textnormal{type definition}
      \\ defKind
      & ::= & ùíå\ \textbf{=}\ K
      & \text{kind definition}
      \\ defDataType
      & ::= & \textbf{data}\ id\ param^*\ \textbf{:}\ K\ \textbf{=}\
              constr^*\ \textbf{.}
      & \textnormal{datatype definitions}
     % auxilliary categories for definitions
      \\ 
      \\ checkType
      & ::= & \textbf{:}\ T
      & \textnormal{annotation for term definition}
      \\ param
      & ::= & \textbf{(}x\ \textbf{:}\ C \textbf{)}
      \\ constr
      & ::= & \textbf{\textbar}\ id\ \textbf{:}\ T
    \end{array}
  \]
  \caption{Modules and definitions}
  \label{fig:mods-defs}
\end{figure}

\paragraph{Modules and Definitions}
All Cedilleum source files start with production $mod$, which consists of a module
declaration, a sequence of import statements which bring into scope definitions
from other source files, and a sequence of \textit{commands} defining terms,
types, and kinds. As an illustration, consider the first few lines of a
hypothetical \texttt{list.ced}:

\begin{verbatim}
module list .

import nat .
\end{verbatim}

\noindent Imports are handled first by consulting a global options files
known to the Cedilleum compiler (on *nix systems \verb|~/.cedille/options|)
containing a search path of directories, and next (if that fails) by searching
the directory containing the file being checked.

Term and type definitions are given with an identifier, a classifier (type or
kind, resp.) to check the definition against, and the definition. For term
definitions, giving classifier (i.e. the type) is optional. As an example,
consider the definitions for the type of Church-encoded lists and two variants
of the nil constructor, the first with a top-level type annotation and the
second with annotations sprinkled on binders:

\begin{verbatim}
cList : ‚òÖ ‚ûî ‚òÖ
      = Œª A : ‚òÖ . ‚àÄ X : ‚òÖ . (A ‚ûî X ‚ûî X) ‚ûî X ‚ûî X .

cNil  : ‚àÄ A : ‚òÖ . cList ¬∑ A
      = Œõ A . Œõ X . Œª c . Œª n . n .
cNil' = Œõ A : ‚òÖ . Œõ X : ‚òÖ . Œª c : A ‚ûî X ‚ûî X . Œª n : X . n .
\end{verbatim}

Kind definitions are given without classifiers (all kinds have super-kind
$\Box$), e.g. \verb;ùíåfunc = ‚òÖ ‚ûî ‚òÖ;

Inductive datatype definitions take a set of \textit{parameters} (term and type
variables which remain constant throughout the definition) well as a set of
\textit{indices} (term and type variables which \textit{can} vary), followed by
zero or more constructors. Each constructor begins with ``\textbf{\textbar}''
(though the grammar can be relaxed so that the first of these is optional) and
then an identifier and type is given. As an example, consider the following two
definitions for lists and vectors (length-indexed lists).

\begin{verbatim}
data Bool : ‚òÖ =
  | tt : Bool
  | ff : Bool
  .
data Nat : ‚òÖ =
  | zero : Nat
  | suc  : Nat ‚ûî Nat
  .
data List (A : ‚òÖ) : ‚òÖ =
  | nil  : List
  | cons : A ‚ûî List ‚ûî List
  .
data Vec (A : ‚òÖ) : Nat ‚ûî ‚òÖ =
  | vnil  : Vec zero
  | vcons : ‚àÄ n: Nat. A ‚ûî Vec n ‚ûî Vec (succ n)
  .
\end{verbatim}

\paragraph{Types and Kinds}
\begin{figure}[h]
  \[
    \begin{array}{rlll}
      \text{Sorts } S
      & ::= & \square & \text{sole super-kind}
      \\ & & K & \text{kinds}
      \\ \text{Classifiers } C
      & ::= & K & \text{kinds}
      \\ & & T & \text{types}
      \\ \text{Kinds } K
      & ::= & \textbf{Œ†}\ x\ \textbf{:}\ C\ \textbf{.}\ K
      & \textnormal{explicit product}
      \\ & & C\ \textbf{‚ûî}\ K
      & \textnormal{kind arrow}
      \\ & & \textbf{‚òÖ}
      & \text{the kind of types that classify terms}
      \\ & & \textbf{(}K\textbf{)}
      \\ 
      \\ \text{Types } T
      & ::= & \textbf{Œ†}\ x\ \textbf{:}\ T\ \textbf{.}\ T
         & \textnormal{explicit product}
      \\ & &  \textbf{‚àÄ}\ x\ \textbf{:}\ C\ \textbf{.}\ T
         & \textnormal{implicit product}
      \\ & &  \textbf{Œª}\ x\ \textbf{:}\ C\ \textbf{.}\ T
         & \textnormal{type-level function}
      \\ & & T\ \textbf{‚ûæ}\ T'
         & \textnormal{arrow with erased domain}
      \\ & & T\ \textbf{‚ûî}\ T'
         & \textnormal{normal arrow type}
      \\ & & T\ \textbf{¬∑}\ T'
         & \text{application to another type}
      \\ & & T\ t
         & \text{application to a term}
      \\ & & \textbf{\{}\ p\ ‚âÉ\ p' \textbf{\}}
         & \textnormal{untyped equality}
      \\ & & \textbf{(}T\textbf{)}
      \\ & & X
         & \text{type variable}
      \\ & & \bullet
         & \text{hole for incomplete types}
    \end{array}
  \]
  \caption{Kinds and types}
  \label{fig:kinds-types}
\end{figure}

In Cedilleum, the expression language is stratified into three main ``classes'':
kinds, types, and terms. Kinds and types are listed in Figure
\ref{fig:kinds-types} and terms are listed in Figure \ref{fig:ann-terms} along
with some auxiliary grammatical categories. In both of these figures, the
constructs forming expressions are listed from lowest to highest precedence --
``abstractors'' ($\lambda\ \Lambda\ \Pi\ \forall$) bind most loosely and
parentheses most tightly. Associativity is as-expected, with arrows (‚ûî ‚ûæ) and
applications being left-associative and abstractors being right-associative.

% TODO cite
The language of kinds and types is similar to that found in the Calculus of
Implicit Constructions\footnote{Cite}. Kinds are formed by dependent and
non-dependent products (Œ† and ‚ûî) and a base kind for types which can classify
terms (‚òÖ). Types are also formed by the usual (dependent and non-dependent)
products (Œ† and ‚ûî) and also \textit{implicit} products (‚àÄ and ‚ûæ) which quantify
over erased arguments (that is, arguments that disappear at run-time).
Œ†-products are only allowed to quantify over terms as all types occurring in
terms are erased at run-time, but ‚àÄ-products can quantify over types
\textit{and} terms because terms can be erased. Meanwhile, non-dependent
products (‚ûî and ‚ûæ) can only ``quantify'' over terms because non-dependent type
quantification does not seem particularly useful. Besides these, Cedilleum
features type-level functions and applications (with term and type arguments),
and a primitive equality type for untyped terms. Last of all is the ``hole''
type (‚óè) for writing partial type signatures or incomplete type applications.
There are term-level holes as well, and together the two are intended to help
facilitate ``hole-driven development'': any hole automatically generates a type
error and provides the user with useful contextual information.

We illustrate with another example: what follows is a module stub for
\textbf{DepCast} defining dependent casts -- intuitively, functions from $a : A$
to $B\ a$ that are also equal\footnote{Module erasure, discussed below} to
identity -- where the definitions \texttt{CastE} and \texttt{castE} are
incomplete.

\begin{verbatim}
module DepCast .

CastE ‚óÇ Œ† A : ‚òÖ . (A ‚ûî ‚òÖ) ‚ûî ‚òÖ = ‚óè .
castE ‚óÇ ‚àÄ A : ‚òÖ . ‚àÄ B : A ‚ûî ‚òÖ . CastE ¬∑ A ¬∑ B ‚ûæ Œ† a : A . B a = ‚óè .
\end{verbatim}
  
\paragraph{Annotated Terms}
\begin{figure}[h]
  \[
    \begin{array}{rlll}
      \text{Subjects } s
      & ::= & t & \text{term}
      \\ & & T & \text{type}
      \\ \text{Terms } t
      & ::= & \textbf{Œª}\, x\ class^?\! \textbf{.}\, t
      & \textnormal{normal abstraction}
      \\ & & \textbf{Œõ}\, x\ class^?\! \textbf{.}\, t
      & \textnormal{erased abstraction}
      \\ & & \textbf{[}\ defTermOrType\ \textbf{]}\ \textbf{-}\ t
      & \text{let definitions}
      \\ & & \textbf{œÅ}\ t\ \textbf{-}\ t'
      & \text{equality elimination by rewriting}
      \\ & & \textbf{œÜ}\ t\ \textbf{-}\ t'\ \textbf{\{} t'' \textbf{\}}
      & \text{type cast}
      \\ & & \textbf{œá}\ T\ \textbf{-}\ t
      & \text{check a term against a type}
      \\ & & \textbf{Œ¥}\ \textbf{-}\ t
      & \text{ex falso quodlibet}
      \\ & & \textbf{Œ∏}\ t\ t'^*
      & \text{elimination with a motive}
      \\ & & t\ t'
      & \text{applications}
      \\ & & t\ \textbf{-}t'
      & \text{application to an erased term}
      \\ & & t\ \textbf{¬∑}T
      & \text{application to a type}
      \\ & & \textbf{Œ≤}\ \textbf{\{} t \textbf{\}}
      & \textnormal{reflexivity of equality}
      \\ & & \textbf{œÇ}\ t
      & \textnormal{symmetry of equality}
      \\ & & \mufix{u}{t\ motive^?}{case^*}
      & \textnormal{type-guarded pattern match and fixpoint}
      \\ & & \mumat{t\ motive^?}{case^*}
      & \text{auxiliary pattern match}
      \\ & & u
      & \text{term variable}
      \\ & & \textbf{(}t\textbf{)}
      \\ & & \bullet
      & \text{hole for incomplete term}
      \\ \\ case
      & ::= & \textbf{\textbar}\ c\ vararg^*\ \textbf{‚Ü¶}\ t
      & \text{pattern-matching cases}
      \\ vararg
      & ::= & u
      & \text{normal constructor argument}
      \\ & & \textbf{-}u
      & \text{erased constructor argument}
      \\ & & \textbf{¬∑}X
      & \text{type constructor argument}
      \\ class
      & ::= & \textbf{:}\ C
      \\ motive
      & ::= & \textbf{@}\ T
      & \textnormal{motive for induction}
    \end{array}
  \]
  \caption{Annotated Terms}
  \label{fig:ann-terms}
\end{figure}

Terms can be explicit and implicit functions (resp. indicated by Œª and Œõ) with
optional classifiers for bound variables, let-bindings, applications $t\ t'$,
$t\ \mhyph t'$, and $t\ \cdot T$ (resp. to another term, an erased term, or a
type). In addition to this there are a number of useful operators for
equaltional reasoning, type casting, providing annotations, and pattern
matching. Each operator will be discussed in more detail in Section
\ref{sec:type-system}, but a few concrete programs in Cedilleum are given below
merely to give a better idea of the syntax of the language.

\begin{verbatim}
isvnil : ‚àÄ A: ‚òÖ. ‚àÄ n: Nat. Vec ¬∑A n ‚ûî Bool
       = Œõ A. Œõ n. Œª xs. Œº' xs @(Œõ n . Œª xs . Bool) {
           | vnil          ‚Ü¶ tt
           | vcons -n x xs ‚Ü¶ ff
           }.
vlength : ‚àÄ A: ‚òÖ. ‚àÄ n: Nat. Vec ¬∑A n ‚ûî Nat
        = Œõ A. Œõ n. Œª xs. Œº len . xs @(Œõ n . Œª x . Nat) {
            | vnil          ‚Ü¶ zero
            | vcons -n x xs ‚Ü¶ suc (len -n xs)
            }.
\end{verbatim}

\section{Erasure and Reduction}

\begin{figure}[h]
  \[
  \begin{array}{lll}
       |x| & = & x 
    \\ |\star| & = & \star 
    \\ |\Box| & = & \Box 
    \\ |\beta\ \{t\}| & = & |t|
    \\ |\delta\ t| & = & |t|
    \\ |\chi\ T^? \textbf{-}\ t| & = & |t| 
    \\ |\varsigma\ t| & = & |t|
    \\ |t\ t'| & = & |t|\ |t'|
    \\ |t\ \mhyph t'| & = & |t| 
    \\ |t\ \cdot T| & = & |t| 
    \\ |\rho\ t\ \mhyph\ t'| & = & |t'| 
    \\ |\abs{\forall}{x}{C}{C'}| & = & \abs{\forall}{x}{|C|}{|C'|}
    \\ |\abs{\Pi}{x}{C}{C'}| & = & \abs{\Pi}{x}{|C|}{|C'|}
    \\ |\abs{\lambda}{u}{T}{t}| & = &  \absu{\lambda}{u}{|t|} 
    \\ |\absu{\lambda}{u}{t}| & = &  \absu{\lambda}{u}{|t|} 
    \\ |\abs{\lambda}{X}{K}{C}| & = &  \abs{\lambda}{X}{|K|}{|C|} 
    \\ |\abs{\Lambda}{x}{C}{t}| & = &  |t| 
    \\ |\phi\ t\ \mhyph\ t'\ \{t''\}| & = & |t''| 
    \\ |[ x = t : T]|\ \mhyph\ t' | & = & (\absu{\lambda}{x}{|t'|})\ |t|
    \\ |[X = T : K]\ \mhyph\ t | & = & |t| 
    \\ |\{ t \simeq t' \}|| & = & \{ |t| \simeq |t'| \}
    \\ |\mufix{u,}{t\ motive^?}{case^*}|
           & = & \mufix{u}{|t|}{|case^*|}
    \\ |\mumat{t\ motive^?}{case^*}|
           & = & \mumat{|t|}{|case^*|}
    \\ \\ |id\ vararg^* \mapsto t| & = & id\ |vararg^*|\ \mapsto |t|
    \\ 
    \\ |\mhyph u| & = & 
    \\ |\cdot X|  & = &
  \end{array}
  \]
  \caption{Erasure for annotated terms}
  \label{fig:eraser}
\end{figure}

The definition of the erasure function given in Figure \ref{fig:eraser} takes
the annotated terms from Figures \ref{fig:kinds-types} and \ref{fig:ann-terms} to
the untyped terms of Figure \ref{fig:pure-terms}. The last two equations
indicate that any type or erased arguments in the the zero or more $vararg$'s of
pattern-match case are indeed erased. The additional constructs introduced in
the annotated term language such as Œ≤, œÜ, and œÅ, are all erased to the language
of pure terms.

Reduction rules are defined for the untyped term language. In essence, to run a
Cedilleum program you first erase it, then reduce it.

\paragraph{$\beta$-reduction}
\[ (\absu{\lambda}{x}{p_1})\ p_2 \reduce_{\beta} [p_2/x]p_1 \]

The rule for $\beta$-reduction is standard: those expressions consisting of a
$\lambda$-abstraction as the left component of an application reduce by having
their bound variable substituted away by the given argument (where $[p_2/x]$ is
the simultaneous and capture-avoiding substitution of $p_2$ for $x$)

\paragraph{$\mu'$-reduction}
\[ \mu'\ (c_i\ p_1 ... p_n)\ \{...\ | c_i\ u_1 ... u_n \mapsto f\ |...\}
  \reduce_{\mu'} [p_1 ... p_n/u_1 ... u_n]f\]

$\mu'$-reduction is a simple pattern-matching reduction rule: if the scrutinee
of $\mu'$ is some variable-headed application $c_i\ p_1 ... p_n$ where the head
$c_i$ matches one of the branch patterns, replace the entire expression with the
branch body $f$ after substituting each of the bound variables of the branch
pattern $u_1 ... u_n$ with the scrutinee's arguments $p_1 ... p_n$

\paragraph{$\mu$-reduction}
\[ \infer[\mu]
  { \mu\ u. (c\ p_1 ... p_n)\ \{ c_i\ u_{i1} ... u_{ij_i} \mapsto f_i
    \}_{i=1..n} \reduce_{\mu} [p_1 ... p_n/u_1 ... u_n][u/p_{\mu}]f}
  {
    \exists i.\ c\!=\!c_i \land j_i\!=\!n
    \quad p_{\mu} = \absu{\lambda}{v}{\mu\ u.\ v\ \{c_i\ u_{i1} ... u_{ij_i}
      \mapsto f_i\}_{i=1..n}}
  }
\]

$\mu$-reduction is similar to $\mu'$-reduction, but combines with it fixpoint
reduction. Again, if the scrutinee $c\ p_1 ... p_n$ matches one of the branch
patterns $c_i\ u_{i1} ... u_{ij_i}$ (for some $i$, where $j_i = n$), then we
replace the original $\mu$ expression with the matched branch, replacing each of
the pattern variables $u_1 ... u_n$ with the scrutinee's arguments $p_1 ...
p_n$, but \textit{in addition} we also replace the $\mu$-bound variable $u$
(which represents the entire $\mu$ expression itself) with a function $p_\mu$
that takes its argument $v$ and re-creates the original $\mu$ expression by
scrutinizing $v$.

\section{Type System (sans Inductive Datatypes)}
\label{sec:type-system}

\begin{figure}[h]
  \caption{Contexts}
  \[
    \begin{array}{llll}
      \text{ Typing contexts } \Gamma
      & ::= & \emptyset\ |\ \ann{x}{C},\Gamma\ |\ \ann{x=s}{C},\Gamma
    \end{array}
  \]
\end{figure}
\begin{figure}[h!]
  \[ \small
    \begin{array}{lcr}
      \infer{\Gamma\vdash \star : \Box}{\ }
      & \infer
        { \Gamma\vdash\abs{\Pi}{y}{C}{C'} : S'}
        { \Gamma \vdash C : S
        \quad
        \Gamma,y:C\vdash C' : S'
%        \quad \textit{Var}(y,S)
        }
      & \infer
        {\Gamma\vdash\abs{\forall}{y}{C}{C'} : \star}
        {\Gamma \vdash C : S
        \quad \Gamma,y:C\vdash C' : \star
%        \quad \textit{Var}(y,S)
        }
      \\
      \\ \infer
      { \Gamma \vdash \{p \simeq p' \} : \star}
      { FV(p\ p') \subseteq dom(\Gamma) }
      & \infer
        { \Gamma \vdash \kappa : \Gamma(\kappa)}
        { }
      & \infer
        { \Gamma \vdash X : \Gamma(X)}
        { }
      \\
      \\ \infer
      { \Gamma \vdash \abs{\lambda}{x}{C}{T} : \abs{\Pi}{x}{C}{K}}
      { \Gamma \vdash \abs{\Pi}{x}{C}{K} : \square
      \quad \Gamma, \ann{x}{C} \vdash T : K
      }
      & \infer
        { \Gamma \vdash T\ \cdot T' : [T'/x] K'}
        { \Gamma \vdash T : \abs{\Pi}{x}{K}{K'}
        \quad \Gamma \vdash T' : K}
      & \infer
       { \Gamma \vdash T\ t : [t/x] K}
        { \Gamma \vdash T : \abs{\Pi}{x}{T'}{K}
        \quad \Gamma \decchk t : T' }
    \end{array}
  \]
  \caption{Sort checking \fbox{$\Gamma \vdash C : S$}}
  \label{fig:sort-checking}
\end{figure}

\begin{figure}[h!]
  \[ \small
    \begin{array}{lcr}
      \infer
      { \Gamma \decdir u : \Gamma(u)}{}
      & \infer
        { \Gamma \decdir \abs{\lambda}{x}{T}{t} : \abs{\Pi}{x}{T}{T'}}
        { \Gamma \vdash T : K
        \quad \Gamma, \ann{x}{T} \decdir t : T'}
      & \infer
        { \Gamma \decchk \absu{\lambda}{x}{t} : \abs{\Pi}{x}{T}{T'}}
        { \Gamma, \ann{x}{T} \decchk t : T'}
      \\
      \\ \infer
      { \Gamma \decdir \abs{\Lambda}{x}{C}{t} : \abs{\forall}{x}{C}{T}}
      { \Gamma \vdash C : S
      \quad x \notin FV(|t|)
      \quad \Gamma, \ann{x}{C} \decdir t : T
      }
      & \infer
        { \Gamma \decchk \absu{\Lambda}{x}{t} : \abs{\forall}{x}{C}{T}}
        { x \notin FV(|t|)
        \quad \Gamma, \ann{x}{C} \decdir t : T
        }
      & \infer
        { \Gamma \decdir t\ t' : [t'/x]T}
        { \Gamma \decsyn t : \abs{\Pi}{x}{T'}{T}
        \quad \Gamma \decchk t' : T'}
      \\
      \\ \infer
      { \Gamma \decdir t\ \cdot T : [T/X]T'}
      { \Gamma \decsyn t : \abs{\forall}{X}{K}{T'}
      \quad \Gamma \vdash T : K}
      & \infer
        { \Gamma \decdir t\ \mhyph t' : [t'/x]T}
        { \Gamma \decsyn t : \abs{\forall}{x}{T'}{T}
        \quad \Gamma \decchk t' : T'}
      & \infer % conversion... maybe needs to include phi and rho now?
        { \Gamma \decchk t : T }
        { \Gamma \decsyn t : T'
          & |T'| =_{\beta} |T| }
      \\ \\ \infer
      { \Gamma \decdir [ id : T = t ]\ \mhyph\ t' : T'}
      { \Gamma \vdash T : K
        & \Gamma \decchk t : T
        & \Gamma, \ann{id = t}{T} \decdir t' : T'}
      & \infer
        { \Gamma \decdir [ id = t]\ \mhyph\ t' : T' }
        { \Gamma \decsyn t : T
          & \Gamma, \ann{id = t}{T} \decdir t' : T'
        }
      & \infer[\footnotemark] % TODO
        { \Gamma \decdir \rho\ t\ \mhyph\ t' : [t_2/x]\ T}
        { \Gamma \decsyn t : \{ t_1 \simeq t_2 \}
          & \Gamma \decsyn t' : [t_1/x]\ T
        }
      \\ \\ \infer
      { \Gamma \decdir [ id : K = T ]\ \mhyph\ t' : T'}
      { \Gamma \vdash K : \square
        & \Gamma \vdash T : K
        & \Gamma, \ann{id = T}{K} \decdir t' : T'}
      & \infer
        { \Gamma \decchk \beta \{t\} : \{ t' \simeq t' \}}
        { \Gamma \vdash \{ t' \simeq t' \} : \star }
      & \infer
        { \Gamma \decdir \varsigma\ t : \{ t_2 \simeq t_1 \} }
        { \Gamma \decdir t : \{ t_1 \simeq t_2 \}}
      \\ \\ \infer
      { \Gamma \decdir \phi\ t\ \mhyph\ t_1\ \{t_2\} : T}
      { \Gamma \decchk t : \{ |t_1| \simeq |t_2| \}
        & \Gamma \decdir t_1 : T}
      & \infer
        { \Gamma \decsyn \chi\ T\ \mhyph\ t : T }
        { \Gamma \decchk t : T }
      & \infer[\footnotemark]
        { \Gamma \decchk \delta\ \mhyph\ t : T }
        { \Gamma \decchk t : \{ \texttt{tt}\ \simeq\ \texttt{ff} \}}
    \end{array}
  \]
  \caption{Type checking \fbox{$\Gamma \decdir s : C$} (sans inductive datatypes)}
  \label{fig:type-checking}
\end{figure}
\footnotetext{Where we assume $t$ does not occur anywhere in $T$}
\footnotetext{Where $\texttt{tt} = \absu{\lambda}{x}{\absu{\lambda}{y}{x}}$ and
  $\texttt{ff} = \absu{\lambda}{x}{\absu{\lambda}{y}{y}}$}
% TODO kind-variables... two different rules or Var check?
% TODO equality, now that it can have rho, phi

The inference rules for classifying expressions in Cedilleum are stratified into
two judgments. Figure \ref{fig:sort-checking} gives the uni-directional rules
for ensuring types are well-kinded and kinds are well-formed. Future versions of
Cedilleum will allow for bidirectional checking for both typing \textit{and}
sorting, allowing for a unification of these two figures. Most of these rules
are similar to what one would expect from the Calculus of Implicit
Constructions, so we focus on the typing rules unique to Cedilleum.

The typing rule for œÅ shows that œÅ is a primitive for rewriting by an (untyped)
equality. If $t$ is an expression that synthesizes a proof that two terms $t_1$
and $t_2$ are equal, and $t'$ is an expression synthesizing type $[t_1/x]\ T$
(where, as per the footnote, $t_1$ does not occur in $T$), then we may
essentially rewrite its type to $[t_2/x]\ T$. The rule for Œ≤ is reflexivity for
equality -- it witnesses that a term is equal to itself, provided that the type
of the equality is well-formed. The rule for œÇ is symmetry for equality.
Finally, œÜ acts as a ``casting'' primitive: the rule for its use says that if
some term $t$ witnesses that two terms $t_1$ and $t_2$ are equal, and $t_1$ has
been judged to have type $T$, then intuitively $t_2$ can also be judged to have
type $T$. (This intuition is justified by the erasure rule for œÜ -- the
expression erases to $|t_2|$). The last rule involving equality is for Œ¥, which
witnesses the logical principle \textit{ex falso quodlibet} -- if a certain
impossible equation is proved (namely that the two Church-encoded booleans
\texttt{tt} and \texttt{ff} are equal), then \textit{any} type desired is
inhabited. The remaining primitive œá allows the user to provide an
explicit top-level annotation for a term.

\section{Inductive Datatypes}
\label{sec:ind-data}

Before we can provide the typing rules for introduction and usage of inductive
datatypes, some auxiliary definitions must be given. The syntax for these, and
the structure of this entire section, borrows heavily from the conventions of the Coq
documentation\footnote{https://coq.inria.fr/refman/language/cic.html\#inductive-definitions}.
The author believes it is worthwhile to restate this development in terms of the
Cedilleum type system, rather than merely pointing readers to the Coq
documentation and asking them to infer the differences between the two systems.

To begin with, the production $defDataType$ gives the concrete syntax for datatype definitions,
but it is not a very useful notation for representing one in the abstract syntax
tree. In our typing rules we will instead use the notation
$\indast{M}{p}{\Gamma_I}{\Sigma}$, where

\begin{itemize}
\item $M$ is a meta-variable ranging over
  constant labels ``C'' and ``A'' (used to distinguish \textbf{c}oncrete and
  \textbf{a}bstracted inductive definitions -- more on this below)
\item $p$ is the number of \textbf{p}arameters of the inductive definition
\item $\Gamma_I$ is a typing context binding \textit{one} type variable $I$, the
  inductive type being defined
\item $\Sigma$ is a typing context containing the $n$ data constructors
  $c_1,...,c_n$ of $I$.
\end{itemize}

For example, consider the \texttt{List} and \texttt{Vec} definitions from
Section \ref{sec:syntax}. These will be represented in the AST as
\\ \\
\[\indast{\text{C}}{1}{List : ‚òÖ ‚ûî ‚òÖ}
{\begin{array}{lcl}
   nil & : & ‚àÄ A : ‚òÖ . List \cdot A
   \\ cons & : & ‚àÄ A : ‚òÖ . A ‚ûî List \cdot A ‚ûî List \cdot A
 \end{array}
}\] and
\\
\[\indast{\text{C}}{1}{Vec : ‚òÖ ‚ûî Nat ‚ûî ‚òÖ}
{\begin{array}{lcl}
   vnil & : & ‚àÄ A: ‚òÖ.Vec \cdot\!A\ zero
   \\ vcons & : & ‚àÄ A: ‚òÖ. ‚àÄ n :Nat. A ‚ûî Vec \cdot\!A\ n ‚ûî Vec \cdot\!A\ (succ\ n)
 \end{array}
}\]

\noindent All inductive types the user will define will be concrete inductive
defintions, and have global scope. Abstracted definitions are automiatically
generated during fix-point pattern matching, and have local scope.

For an inductive datatype definition to be well-formed, it must satisfy the
following conditions (each of which is explained in more detail in Subsections
\ref{ssec:inductive-aux-defs} and \ref{ssec:inductive-wf-def}):

\begin{itemize}
\item The kind of $I$ must be (at least) a \textit{p-arity of kind ‚òÖ}.
\item The types of each $id \in \Sigma$ must be \textit{types of constructors
    of $I$}
\item The definition must satisfy the \textit{non-strict} positivity condition.
\end{itemize}

Similarly, the notation in the grammar of Cedilleum $\mu'$ and $\mu$ for pattern
matching is inconvenient, and we will represent them in the AST as resp.
$\mu'(t,P,t_{i=1..n})$ and
$\mu(x_{\text{rec}},I',x_{\text{to}},t,P,t_{i=1..n})$. Translation from the form
given in the grammar to this form is discussed in detail below, but is as
expected. In particular, we enforce that patterns are exhaustive and
non-overlapping, and that $I'$ and $x_{\text{to}}$ (which correspond to the
automatically generated identifiers like \texttt{Nat/ih} and \texttt{fromNat/ih}
from the introduction) are fresh w.r.t the global and local
context. For example, consider the pattern-matches given in the code listings
for \texttt{isvnil} and \texttt{vlength} above. These would be translated into
the AST as
\\ \\
\[
  \mu'(xs,\absu{\Lambda}{n}{\absu{\lambda}{x}{Bool}},
  \begin{array}{l}
    \absu{\texttt{tt}}
    \\ \absu{\Lambda}{n}{\absu{\lambda}{x}{\absu{\lambda}{xs}{\texttt{ff}}}}
  \end{array}
  )
\] and
\[ \mu(len, Vec/len, fromVec/len,xs,\absu{\Lambda}{n}{\absu{\lambda}{x}{Nat}},
  \begin{array}{l}
    \texttt{zero}
    \\ \absu{\Lambda}{n}{\absu{\lambda}{x}{\absu{\lambda}{xs}{succ\ (len\ \mhyph
    n\ xs)}}}
    % \absu{\Lambda}{n}{\absu{\Lambda}{m}{\absu{\lambda}{x}{\absu{\lambda}{xs}{\absu{\Lambda}{eq}{suc\
    % (len\ \mhyph n\ xs)}}}}}
  \end{array})
\]

\noindent In general, the generated name for $I'$ and $x_{\text{to}}$ that users
will write in Cedilleum programs will be of the form ``$I\texttt{/}x_{\text{rec}}$''
and ``$\texttt{from}I\texttt{/}x_{\text{rec}}$''.

For a pattern construct ($\mu$ or $\mu'$) in the AST to be well-formed, it must satisfy the
following conditions (each of which is, again, explained in more detail in
Subsections \ref{ssec:pattern-valid-elim}, \ref{ssec:pattern-wf-pat}, and
\ref{ssec:patern-abstracted-gen}):

\begin{itemize}
\item The motive $P$ must be well-kinded
\item $P$ must be a legal motive to be used in eliminating the inductive type
  $I$ of the scrutinee $t$
\item Each branch $t_i$ must have the type expected given the constructor $c_i
  \in \Sigma$ and the motive $P$.
\end{itemize}

\subsection{Auxiliary Definitions}
\label{ssec:inductive-aux-defs}

\paragraph{Contexts}
To ease the notational burden, we will introduce some conventions for writing
contexts within terms and types.

\begin{itemize}
\item We write $\lambda\,\Gamma$, $\Lambda\,\Gamma$, $\forall\,\Gamma$, and
  $\Pi\,\Gamma$ to indicate some form of abstraction over each variable in
  $\Gamma$. For example, if $\Gamma = \ann{x_1}{T_1},\ann{x_2}{T_2}$ then
  $\absu{\lambda}{\Gamma}{t} =
  \abs{\lambda}{x_1}{T_1}{\abs{\lambda}{x_2}{T_2}{t}}$. Additionally, we
  will also write $\piforall\,\Gamma$ to indicate an arbitrary mixture of $\Pi$
  and $\forall$ quantified variables. Note that \textit{if $\piforall\,\Gamma$
  occurs multiple times within a definition or inference rule}, the intended
  interpretation is that \textit{all occurrences have the same mixture of $\Pi$
    and $\forall$ quantifiers}.
\item $\lenc{\Gamma}$ denotes the length of $\Gamma$ (the number of variables it
  binds)
\item We write $s\ \Gamma$ to indicate the sequence of variable arguments in
  $\Gamma$ given as arguments to $s$. Implicit in this notation is the removal
  of typing annotations from the variables $\Gamma$ when these variables are
  given as arguments to $s$.

  Since in Cedilleum there are three flavors of applications (to a type, to an
  erased term, and to an unerased term), we will only us this notion when the type
  or kind of $s$ is known, which is sufficient to disambiguate the flavor of
  application intended for each particular binder in $\Gamma$. For example,
  if $s$ has type
  $\abs{\forall}{X}{‚òÖ}{\abs{\forall}{x}{X}{\abs{\Pi}{x'}{X}{X}}}$ and $\Gamma =
  \ann{X}{‚òÖ},\ann{x}{X},\ann{x'}{X}$ then $s\ \Gamma = s\ \cdot X\ \mhyph x\ x'$
\item $\Delta$ and $\Delta'$ are notations we will use
  for a specially designated contexts associating type variables with both global
  ``concrete'' and local ``abstracted'' inductive data-type declarations.
  The purpose of this latter sort of declaration is to enable type-guided
  termination of definitions using fixpoints (see Section \ref{ssec:typing-rules}) For example, given
  just the (global) data type declaration of $Vec$, we would have $\Delta(Vec) =
  \indast{\text{C}}{1}{\Gamma_{Vec}}{\Sigma}$, where $\Gamma_{Vec} = \ann{Vec}{‚òÖ ‚ûî Nat ‚ûî
    ‚òÖ}$ and  $\Sigma$ binds data constructors $vnil$ and $vcons$ to the
  appropriate types.
\end{itemize}

\paragraph{$p$-arity}

A kind $K$ is a $p$-arity if it can be written as $\absu{\Pi}{\Gamma}{K'}$ for
some $\Gamma$ and $K'$, where $\lenc{\Gamma} = p$. For an inductive definition
$\indast{M}{p}{\Gamma_I}{\Sigma}$, requiring that the kind $\Gamma_{I}(I)$ is a $p$-arity
of ‚òÖ ensures that $I$ \textit{really does have} $p$ parameters.

\paragraph{Types of Constructors}
% TODO: if you look at the `generation of abstracted inductive definitions', it
% uses a different format for the types associated with the constructors in
% \Sigma -- that is the \piforall notation. This section probably should be
% reworked to that end.
$T$ is a \textit{type of a constructor of $I$} iff
\begin{itemize}
\item it is $I\ s_1 ... s_n$
\item it can be written as $\abs{\forall}{s}{C}{T}$ or $\abs{\Pi}{s}{C}{T}$,
  where (in either case) $T$ is a type of a constructor of $I$
\end{itemize}

\paragraph{Positivity condition}
The positivity condition is defined in two parts: the positivity condition of
a type $T$ of a constructor of $I$, and the positive occurence of $I$ in $T$.
We say that a type $T$ of a constructor of $I$ satisfies the positivity condition
when

\begin{itemize}
\item $T$ is $I\ s_1... s_n$ and $I$ does not occur anywhere in $s_1...s_n$
\item $T$ is $\abs{\forall}{s}{C}{T'}$ or $\abs{\Pi}{s}{C}{T'}$, $T'$ satisfies
  the positivity condition for $I$, and $I$ occurs \textit{only} positively in $C$ 
\end{itemize}

\noindent We say that $I$ occurs only positively in $T$ when
\begin{itemize}
\item $I$ does not occur in $T$
\item $T$ is of the form $I\ s_1 ... s_n$ and $I$ does not occur in $s_1 ...
  s_n$
\item $T$ is of the form $\abs{\forall}{s}{C}{T'}$ or $\abs{\Pi}{s}{C}{T'}$, $I$
  occurs only positively in $T'$, and $I$ \textit{does not} occur positively in $C$
\end{itemize}

\subsection{Well-formed inductive definitions}
\label{ssec:inductive-wf-def}

Let $\Gamma_{\text{P}},\Gamma_I,$ and $\Sigma$ be contexts such that $\Gamma_I$
associates a single type-variable $I$ to kind $\absu{\Pi}{\Gamma_{\text{p}}}{K}$ and
$\Sigma$ associates term variables $c_1 ... c_n$ with corresponding types
$\absu{\forall}{\Gamma_{\text{P}}}{T_{1}},...\absu{\forall}{\Gamma_{\text{P}}}{T_{n}}$.
Then the rule given in Figure \ref{fig:inductive-intro} states when an inductive
datatype definition may be introduced, provided that the following side
conditions hold:

\begin{figure}[h]
  \caption{Introduction of inductive datatype}
  \label{fig:inductive-intro}
  \[
    \infer
    { \indast{M}{p}{\Gamma_I}{\Sigma}\ wf}
    { \emptyset \vdash \Gamma_I(I) : \square
      \quad \lenc{\Gamma_P} = p
      \quad (\Gamma_I,\Gamma_P \vdash T_i : ‚òÖ)_{i=1..n}
    }
  \]
\end{figure}

\begin{itemize}
  \item Names $I$ and $c_1..c_n$ are distinct from any other inductive datatype
    type or constructor names, and distinct amongst themselves
  \item Each of $T_1..T_n$ is a type of constructor of $I$ which satisfies the
    positivity condition for $I$. Furthmore, each occurence of $I$ in $T_i$ is
    one which is applied to the parameters $\Gamma_P$.
  \item Identifiers $I$, $c_1,...,c_n$ are fresh w.r.t the global context, and
    do not overlap with each other nor any identifiers in $\Gamma_P$.
\end{itemize}

When an inductive data-type has been defined using the $defDataType$ production,
it is understood that this always a concrete inductive type, and it (implicitly)
adds to a global typing context the variable bindings in $\Gamma_I$ and
$\Sigma$. Similarly, when checking that the kind $\Gamma_I(I)$ and type $T_i$
are well-sorted and well-kinded, we assume an (implicit) global context of
previous definitions.

\subsection{Valid Elimination Kind}
\label{ssec:pattern-valid-elim}

\begin{figure}[h]
  \caption{Valid elimination kinds}
  \label{fig:valid-elim-kind}
  \[
    \begin{array}{ccc}
      \infer
      { \llbracket T : ‚òÖ\ |\ T \to ‚òÖ \rrbracket }
      { }
      & \infer
        { \llbracket T : \abs{\Pi}{s}{C}{K}\ |\ \abs{\Pi}{s}{C}{K'} \rrbracket}
        { \llbracket T\ s : K\ |\ K' \rrbracket }
    \end{array}
  \]
\end{figure}

When type-checking a pattern match (either $\mu$ or $\mu'$), we need to know
that the given motive $P$ has a kind $K$ for which elimination of a term with
some inductive data-type $I$ is permissible. We write this judgment as
$\llbracket \ann{T}{K'} | K \rrbracket$, which should be read ``the type $T$ of kind $K'$ can
be eliminated through pattern-matching with a motive of kind $K$''. This
judgment is defined by the simple rules in Figure \ref{fig:valid-elim-kind}. For
example, a valid elimination kind for the indexed type family $Vec\ \cdot X$
(which has kind $\abs{\Pi}{n}{Nat}{‚òÖ}$) is $\abs{\Pi}{n}{Nat}{\abs{\Pi}{x}{Vec\
    \cdot X\ n}{‚òÖ}}$

\subsection{Valid Branch Type}

Another piece of kit we need is a way to ensure that, in a pattern-matching
expression, a particular branch has the correct type given a particular
constructor of an inductive data-type and a motive. We write $\llbrace c : T
\rrbrace^P_I$ to indicate the type corresponding to the (possibly partially
applied) constructor $c$ of $I$ and its type $T$. We
abbreviate this notation to $\llbrace c \rrbrace^P$ when the inductive type
variable $I$, and the type $T$ of $c$, is known from the (meta-language) context.

\[
  \begin{array}{rcl}
    \llbrace c : I\ \vars{T}\ \vars{s} \rrbrace^P_I
    & = & P\ \vars{s}\ c
    \\ \llbrace c : \abs{\forall}{x}{T'}{T} \rrbrace^P_I
    & = & \abs{\forall}{x}{T'}{\llbrace c\ \mhyph x : T \rrbrace^P_I }
    \\ \llbrace c : \abs{\forall}{x}{K}{T} \rrbrace^P_I
    & = & \abs{\forall}{x}{K}{\llbrace c\ \cdot x : T \rrbrace^P_I }
    \\ \llbrace c : \abs{\Pi}{x}{T'}{T} \rrbrace^P_I
    & = & \abs{\Pi}{x}{T'}{\llbrace c\ x : T \rrbrace^P_I }
  \end{array}
\]

\noindent where we leave implicit the book-keeping required to separate the
parameters $\vars{T}$ from the indicies $\vars{s}$.

The biggest difference bewteen this definition and the similar one found in the
Coq documentation is that types can have implicit and explicit quantifiers, so
we must make sure that the types of branches have implicit / explicit
quantifiers (and the subjects $c$ have applications for types, implicit terms, and
explicit terms), corresponding to those of the arguments to the data constructor
for the pattern for the branch.

\subsection{Well-formed Patterns}
\label{ssec:pattern-wf-pat}

\begin{figure}[h]
  \caption{Well-formedness of a pattern}
  \label{fig:wf-pattern}
  \[
    \infer
    { \wfpat{\Gamma,\Delta}{\indast{M}{p}{\Gamma_I}{\Sigma}}{\vars{T}}{\mu'(t,P,t_{i=1..n})}
    }
    { \Gamma \vdash P : K
      \quad \Sigma = \ann{c_1}{\absu{\forall}{\Gamma_P}{T_1}}, ..., \ann{c_n}{\absu{\forall}{\Gamma_P}{T_n}}
      \quad \lenc{\vars{T}} = \lenc{\Gamma_p} = p
      \quad \llbracket I\ \vars{T}\, : \Gamma(I)\, |\, K \rrbracket
      \quad (\Gamma,\Delta \decchk t_i : \llbrace c_i\ \vars{T} \rrbrace^P)_{i=1..n}
    }
  \]
\end{figure}

% TODO 
Figure \ref{fig:wf-pattern} gives the rule for checking that a pattern
$\mu'(t,P,t_{i=1..n})$ is well-formed. We check that the motive $P$ is
well-kinded at kind $K$, that the given parameters $\vars{T}$ match the expected
number $p$ from the inductive data-type declaration, that an inductive data-type
$I$ instantiated with the given parameters $\vars{T}$ can be eliminated to a
type of kind $K$, and that the given branches $t_i$ account for each of the
constructors $c_i$ of $\Sigma$ and have the required branch type $\llbrace c_i\
\vars{T} \rrbrace^P$ under the given local context $\Gamma$ and context of
inductive data-type declarations $\Delta$.

\subsection{Generation of Abstracted Inductive Definitions}
\label{ssec:patern-abstracted-gen}

Cedilleum supports \textit{histomorphic} recursion (that is, having access to
all previous recursive values) where termination is ensured
through typing. In order to make this possible, we need a mechanism for tracking
the global definitions of \textit{concrete} inductive data types as well the
locally-introduced \textit{abstract} inductive data type representing the
recursive occurences suitable for a fixpoint function to be called on.

If $I$ is an inductive type such that $\Delta(I) =
\indast{\text{C}}{p}{\Gamma_I}{\Sigma}$ and $I'$ is a fresh type variable, then we
define function $Hist(\Delta,I,\vars{T},I')$ producing an abstracted (well-formed)
inductive definition $\indast{\text{A}}{0}{\Gamma_{I'}}{\Sigma'}$, where

\begin{itemize}
\item $\Gamma_{I'}(I') = \absu{\forall}{\Gamma_D}{‚òÖ}$ if $\Gamma_{I}(I) =
  \absu{\forall}{\Gamma_{P}}{\absu{\forall}{\Gamma_D}{‚òÖ}}$ (and $\lenc{\Gamma_P}
  = \lenc{\vars{T}} = p$)

  That is, the kind of $I'$ is the same as the kind of $I\ \vars{T}$
\item $\Sigma' = \ann{c'_1}{\absu{\forall}{\Gamma_D}
    { \absu{\piforall}{\Gamma_{A'_1}}{I'\ \Gamma_D} }},...,
  \ann{c'_n}{\absu{\forall}{\Gamma_D}
    { \absu{\piforall}{\Gamma_{A'_n}}{I\ \vars{T}\ \Gamma_D} }}$,

  when each of the concrete constructors $c_i$ in $\Sigma$ are associated with
  type $\absu{\forall}{\Gamma_P}{
    \absu{\forall}{\Gamma_D}{ \absu{\piforall}{\Gamma_{A_i}}{I\ \Gamma_P\
        \Gamma_D} } }$ and each $\Gamma_{A'_i} =
  [\absu{\lambda}{\Gamma_P}{I'}/I,\vars{T}/\Gamma_P]\Gamma_{A_i}$.

  That is, trasforming the concrete constructors of the inductive datatype $I$
  to ``abstracted'' constructors involves replacing each recursive occurrence of
  $I\ \Gamma_P$ with the fresh type variable $I$, and instantiating each of the
  parameters $\Gamma_P$ with $\vars{T}$.
\end{itemize}

Users of Cedilleum will see ``punning'' of the concrete constructors $c_i$ and
abstracted constructors $c'_i$. In particular, when using fix-point pattern
matching branch labels will be written with the constructors for the concrete
inductive data-type, and the expected type of a branch given by the motive will
pretty-print using the concrete constructors. In the inference rules, however,
we will take more care to distinguish the abstract constructors (see Subsection
\ref{ssec:typing-rules}).

\subsection{Typing Rules}
\label{ssec:typing-rules}

\begin{figure}[h]
  \caption{Use of an inductive datatype $\indast{M}{p}{\Gamma_I}{\Sigma}$}
  \label{fig:inductive-use}
  \[ \footnotesize
    \begin{array}{c}
      \infer
      { \Gamma,\Delta \decdir \mu'(t,P,t_{i=1..n}) : P\ \vars{s}\ t}
      { \Gamma \decsyn t : I\ \vars{T}\ \vars{s}
      \quad \wfpat{\Gamma,\Delta}{\Delta(I)}{\vars{T}}{\mu'(t,P,t_{i=1..n})}
      }
      \\ \\
      \\ \infer
      { \Gamma,\Delta \decdir \mu(x_{\text{rec}}, I',
      x_{\text{to}},t,P,t_{i=1..n}) : P\ \vars{s}\ t
      }
      {
      \begin{array}{c}
        \begin{array}{cccc}
          \Gamma \decsyn t : I\ \vars{T}\ \vars{s}
          & \Delta(I) = \indast{\text{C}}{p}{\Gamma_I}{\Sigma}
          & \Gamma_I(I) =
            \absu{\Pi}{\Gamma_P}{\absu{\Pi}{\Gamma_{\text{D}}}{‚òÖ}},\lenc{\Gamma_P}
            = p
          & Hist(\Delta,I,\vars{T},I') = \indast{\text{A}}{0}{\Gamma_{I'}}{\Sigma'}
        \end{array}
        \\ \\
        \begin{array}{cc}
          \Gamma' = \Gamma,\Gamma_{I'},
          \ann
           {x_{\text{to}}=\absu{\Lambda}{\Gamma_D}{\absu{\lambda}{x}{x}}}
           { \absu{\forall}{\Gamma_{\text{D}}}{I'\
            \Gamma_{\text{D}} \to I\ \vars{T}\
            \Gamma_{\text{D}}}},
          \ann{x_{\text{rec}}}{\absu{\forall}{\Gamma_{\text{D}}}{\abs{\Pi}{x}{I'\
          \Gamma_{\text{D}}}{P\ \Gamma_{\text{D}}\ (x_{\text{to}}\ \Gamma_D\ x)}
          }}
          & \Delta' = \Delta,Hist(\Delta,I,\vars{T},I')
        \end{array}
        \\ \\
        \begin{array}{cc}
          % P' = \absu{\lambda}{\Gamma_D}{\abs{\lambda}{x}{I\ \vars{T}\ \Gamma_D}{P\ 
          % \Gamma_D\ x} }
          \wfpat{\Gamma',\Delta'}{\Delta'(I')}{\varnothing}{\mu'(t,P,t_{i=1..n})}
        \end{array}
      \end{array}
      }
    \end{array}
  \]
\end{figure}

The first rule of Figure \ref{fig:inductive-use} is for typing simple pattern
matching with $\mu'$. We need to know that the scrutinee $t$ is well-typed at
some inductive type $I\ \vars{T}\ \vars{s}$, where $\vars{T}$ represents the
parameters and $\vars{s}$ the indicies. Then we defer to the judgment
$WF\mhyph\!Pat$ to ensure that this pattern-matching expression is a valid
elimination of $t$ to type $P$.

The second rule is for typing pattern-matching with fix-points, and is
significantly more involved. As above we check the scrutinee $t$ has some
inductive type $I\ \vars{T}\ \vars{s}$. We confirm that $I$ is a
\textit{concrete} inductive data-type by looking up its definition in $\Delta$,
and then generate the abstracted definition $Hist(\Delta,I,\vars{T},I')$ for some fresh
$I'$. We then add to the local typing context $\Gamma_{I'}$ (the new inductive
type $I'$ with its associated kind) and two new variables $x_{\text{to}}$ and
$x_{\text{rec}}$.

\begin{itemize}
\item $x_{\text{to}}$ is the \textit{revealer}. It casts a term of an abstracted inductive
  data-type $I'\ \Gamma_D$ to the concrete type $I\ \vars{T}\ \Gamma_D$.
  Crucially, it is an \textit{identity} cast (the implicit quantification
  $\Lambda \Gamma_D$ disappears after erasure). The intuition why this should be
  the case is that the abstracted type $I'$ only serves to mark the recursive
  occurrences of $I$ during pattern-matching to guarantee termination.
\item $x_{\text{rec}}$ is the \textit{recursor} (or the inductive hypothesis).
  Its result type $P'\ \Gamma_D\ x$ utilizes $x_{\text{to}}$ in $P'$ to be
  well-typed, as the $x$ in this expression has type $I'\ \Gamma_D$, but $P$
  expects an $I\ \vars{T}\ \Gamma_D$. Because $x_{\text{to}}$ erases to the identity, uses of the
  $x_{\text{rec}}$ will produce expressions whose types will not interfere with
  producing the needed result for a given branch (see the extended example --
  TODO).
\end{itemize}

\noindent With these definitions, we finish the rule by checking that the
pattern is well-formed using the augmented local context $\Gamma'$ and context
of inductive data-type definitions $\Delta'$.

\section{Elaboration of Inductive Datatypes}
As mentioned in Section \ref{sec:intro}, Cedilleum is not based on CIC. Rather,
its core theory is the \textit{Calculus of Dependent Lambda Eliminations}
(CDLE), whose complete typing rules can are those of Section
\ref{sec:type-system} plus rules for dependent intersections (see
\cite{St18_Cedille-Syntax-Semantics}). That is to say, the preceding treatment
for inductive datatypes (Section \ref{sec:ind-data}) is a high-level and
convenient interface for \textit{derivable} inductive Œª-encodings. This section
explains the elaboration process. Since the generic derivation of inductive
data-types with course-of-value induction has been covered in-depth in [TODO],
we omit these details and instead describe the \textit{interface} such
developments provide which data-type elaboration targets.

At a high level, inductive data-types in Cedilleum are first translated to
\textit{identity mappings}, which are (in the non-indexed case) a class of type
schemes \verb;F: ‚òÖ ‚ûî ‚òÖ; that are more general than functors. The parameter of
the identity scheme replaces all recursive occurrences of the data-type in the
signatures of the constructor and a quantified type variable replaces all
``return type'' occurrences. For example, the type scheme for data-type
\verb;Nat; is \verb;Œª R: ‚òÖ. ‚àÄ X: ‚òÖ. X ‚ûî (R ‚ûî X) ‚ûî X;, with \verb;R; the
parameter and \verb;X; the quantified variable. For the rest of this
section we assume the reader has at least a basic understanding of impredicative
encodings of datatypes (see \cite{PP89_Inductive-Types-CC} and
\cite{Wa90_Rec-Types-For-Free}) and taking the least fix-point of functors (see
\cite{MFP91_Bananas-Lenses-Envelopes-Barbed-Wire}).

% TODO parameters
The following developments are parameterized by an indexed type scheme $F$ of
kind \verb;(Œ† Œì·µ¢. ‚òÖ) ‚Üí (Œ† Œì·µ¢. ‚òÖ); corresponding to the kind
\verb;Œ† Œì·µ¢. ‚òÖ; of inductive data-type $I$ declared as $\indast{I}{p}{\Gamma_I}{\Sigma}$

\subsection{Identity Mappings}
Our first task is to describe identity mappings, the class of type schemes
\verb;F: (Œ† Œì·µ¢. ‚òÖ) ‚ûî Œ† Œì·µ¢. ‚òÖ; we concerned with. Identity mappings are similar to functors
in that they come equipped with a function that resembles
\verb;fmap: ‚àÄ Œì·µ¢. ‚àÄ A B: Œ† Œì·µ¢. ‚òÖ. Œ† f: (A ¬∑Œì·µ¢ ‚ûî B ¬∑Œì·µ¢). F ¬∑(A ¬∑Œì·µ¢) ‚ûî F ¬∑(B ¬∑Œì·µ¢);
except that it need only be defined for an argument \verb;f; that is equal to the
identity function. We define the type \verb;Id; of such functions and declare
(indicated by \verb;<..>;) its elimination principle \verb;elimId·µ¢;:

\begin{verbatim}
Id·µ¢ : Œ† A B: (Œ† Œì·µ¢. ‚òÖ). Œπ id: ‚àÄ Œì·µ¢. A Œì·µ¢ ‚ûî B Œì·µ¢. {id ‚âÉ Œª x. x}.
elimId·µ¢ : ‚àÄ A B: (Œì·µ¢. ‚òÖ). Id·µ¢ ¬∑A ¬∑B ‚ûæ A ‚ûî B = <..>
\end{verbatim}

Recall that since Cedilleum has a Curry-style type system and implicit
products there are many non-trivial functions that erase to identity.
While the definition of \verb;elimId·µ¢; is omitted, it is important to note that
it enjoys the property of erasing to the identity function:
\begin{verbatim}
elimId·µ¢-prop : {elimId·µ¢ ‚âÉ Œª x. x} = Œ≤.
\end{verbatim}

We may now define \verb;IdMapping; as a scheme \verb;F; that comes with a way to
lift identity functions:
\begin{verbatim}
IdMapping·µ¢ : Œ† F: (Œì·µ¢ ‚ûî ‚òÖ) ‚ûî (Œì·µ¢ ‚ûî ‚òÖ). ‚òÖ
  = Œª F. ‚àÄ A B: (Œì·µ¢ ‚ûî ‚òÖ). Œ® Œì·µ¢. Id·µ¢ ¬∑A ¬∑B ‚ûî Id·µ¢ ¬∑(F ¬∑A) ¬∑(F ¬∑B).
\end{verbatim}

Finally, it is convenient to define \verb;fimap; which given an
\verb;IdMapping; and an \verb;Id; function performs the lifting:
\begin{verbatim}
fimap·µ¢ : ‚àÄ F: (Œ† Œì·µ¢. ‚òÖ) ‚ûî (Œ† Œì·µ¢. ‚òÖ). ‚àÄ im: IdMapping·µ¢ ¬∑F. Cast·µ¢ ¬∑A ¬∑B ‚ûæ F ¬∑A ‚ûî F ¬∑B
  = Œõ F im c. Œª f. elimId·µ¢ -(im c) f.
\end{verbatim}

From \verb;elimId·µ¢-prop; it should be clear that \verb;fimap·µ¢; also erases to
\verb;Œª x. x;.

% TODO Re-do View with indexes, too!
\subsection{Type-views of Terms}
A crucial component of course-of-value is the ability to view some term as having
two different types. The idea behind a \verb;View; is similar to that behind the
type \verb;Id; from the previous section, except now we explicitly name the
doubly-typed term:
\begin{verbatim}
View : Œ† A: ‚òÖ. A ‚ûî ‚òÖ ‚ûî ‚òÖ = Œª A a B. Œπ b: B. {a ‚âÉ b}
elimView : ‚àÄ A B: ‚òÖ. Œ† a: A. View ¬∑A a ¬∑B ‚ûæ B = <..>
elimView-prop : {elimView ‚âÉ Œª x. x} = Œ≤.
\end{verbatim}

\subsection{Œª-encoding Interface}
This subsection describes the interface to which data-type declarations are
elaborated; it is parameterized by an identity mapping.

% TODO module parameters!
\begin{verbatim}
module (F·µ¢: (Œ† Œì·µ¢. ‚òÖ) ‚Üí (Œ† Œì·µ¢. ‚òÖ)){im: IdMapping ¬∑F·µ¢}.
\end{verbatim}

% TODO explain derivation?
\noindent where parameters \verb;F·µ¢; and \verb;im; are automatically derived from the
declaration of a positive data-type.

With these two parameters alone, the generic developments of [TODO] provide the
following interface for inductive Œª-encodings of data-types:

\begin{verbatim}
Fix·µ¢ : Œ† Œì·µ¢. ‚òÖ = <..>
in·µ¢  : ‚àÄ Œì·µ¢. F·µ¢ ¬∑Fix·µ¢ Œì·µ¢ ‚ûî Fix·µ¢ Œì·µ¢ = <..>
out·µ¢ : ‚àÄ Œì·µ¢. Fix·µ¢ Œì·µ¢ ‚ûî F·µ¢ ¬∑Fix·µ¢ Œì·µ¢ = <..>

PrfAlg·µ¢ : Œ† P: (Œ† Œì·µ¢. Œ† d: Fix·µ¢ Œì·µ¢. ‚òÖ). ‚òÖ
  = Œª P. ‚àÄ R: (Œ† Œì·µ¢. ‚òÖ).
      ‚àÄ c: Id·µ¢ ¬∑R ¬∑Fix·µ¢.
      Œ† v: View ¬∑(‚àÄ Œì·µ¢. Fix·µ¢ Œì·µ¢ ‚ûî F·µ¢ ¬∑Fix·µ¢ Œì·µ¢) out ¬∑(‚àÄ Œì·µ¢. R Œì·µ¢ ‚ûî F·µ¢ ¬∑R Œì·µ¢).
      Œ† ih: (‚àÄ Œì·µ¢. Œ† r: R Œì·µ¢. P Œì·µ¢ (elimId·µ¢ -c -Œì·µ¢ r)).
      Œ† Œì·µ¢. Œ† fr. F ¬∑R Œì·µ¢.
      P Œì·µ¢ (in·µ¢ -Œì·µ¢ (fimap·µ¢ -im -c fr)).
induction·µ¢ : ‚àÄ P: (Œ† Œì·µ¢. Œ† d: Fix·µ¢ Œì·µ¢. ‚òÖ). PrfAlg·µ¢ ¬∑P ‚ûî ‚àÄ Œì·µ¢. Œ† d: Fix·µ¢ Œì·µ¢. P Œì·µ¢ d
  = <..>
\end{verbatim}

The first three definitions give \verb;Fix·µ¢; as the (least) fixed-point of
\verb;F·µ¢;, with \verb;in·µ¢; and \verb;out·µ¢; representing resp. a generic set of
constructors and destructors. \verb;induction·µ¢; of course is the proof-principle
stating that if one can provide a \verb;PrfAlg; for property \verb;P; (that is,
\verb;P; holds for all \verb;Fix·µ¢; generated by (generic) constructor
\verb;in·µ¢;) then this suffices to show that \verb;P; holds for \textit{all}
\verb;Fix·µ¢;.

We now explain the definition of \verb;PrfAlg·µ¢; in more detail:
\begin{itemize}
  \item \verb;R; is the type of recursive occurrences of the data-type
    \verb;Fix·µ¢;.

    It corresponds directly to types like \verb;rec/Nat; when using
    \verb;Œº; in Cedilleum
  \item \verb;c; is a ``revealer'', that is to say a proof that \verb;R; really
    \textit{is} \verb;Fix·µ¢; witnessed by an identity function.

    It corresponds directly to functions like \verb;rec/cast; when using \verb;Œº;
  \item \verb;v; is evidence that the (generic) destructor \verb;out·µ¢; can be
    used on the recursive occurrence type \verb;R; for further pattern-matching.

    It corresponds directly to \verb;Œº'; (when used outside of \verb;Œº; it
    corresponds to the ``trivial'' view that \verb;out·µ¢; has the type it is
    already declared to have).

  \item \verb;ih; is the inductive hypothesis, stating that property \verb;P;
    holds for all recursive occurrences \verb;R; of an inductive case

    It corresponds directly to the \verb;Œº;-bound variable for fix-point recursion.
  \item \verb;fr; represents the collection of constructors that each \verb;Œº;
    branch must account for.

    For example, for the data-type \verb;Nat; we have identity mapping
    \verb;fr: ‚àÄ X: ‚òÖ. X ‚ûî (R ‚ûî X) ‚ûî X; and Cedilleum cases branches
    \verb;{| zero ‚ûî zcase | succ r ‚ûî scase r }; translate to
    \verb;fr zcase (Œª r. scase r);

  \item Finally, result type \verb;P Œì·µ¢ (in·µ¢ -Œì·µ¢ (fimap·µ¢ -im -c fr)); accounts
    for the return type of each case branch.

    Since \verb;P; is phrased over \verb;Fix·µ¢;, and we have by assumption
    \verb;fr: F·µ¢ ¬∑R Œì·µ¢;, we must first use our identity mapping \verb;im; to
    traverse \verb;fr; and cast each recursive occurrence \verb;R Œì·µ¢; to
    \verb;Fix·µ¢ Œì·µ¢;, producing an expression of type \verb;F ¬∑Fix·µ¢ Œì·µ¢; which we are
    then able to transform into \verb;Fix·µ¢ Œì·µ¢; using (generic) constructor \verb;in·µ¢;.
\end{itemize}

While the definitions of \verb;in·µ¢;, \verb;out·µ¢;, and \verb;induction·µ¢; are
omitted, it is important that they have the following computational behavior
(guaranteed by [TODO]):
\begin{verbatim}
lambek1·µ¢ : ‚àÄ Œì·µ¢. Œ† gr: F·µ¢ Fix·µ¢ Œì·µ¢. {out·µ¢ (in·µ¢ gr) ‚âÉ gr} = Œ≤.
lambek2·µ¢ : ‚àÄ Œì·µ¢. Œ† d: Fix·µ¢ Œì·µ¢. {in (out d) ‚âÉ d}
  = induction·µ¢ ¬∑(Œª Œì·µ¢. Œª x: Fix·µ¢ Œì·µ¢. {in (out x) ‚âÉ x})
     (Œõ R. Œõ c. Œª o. Œõ eq. Œª ih. Œª gr. Œ≤).

inductionCancel·µ¢ : ‚àÄ P: (Œ† Œì·µ¢. Fix·µ¢ Œì·µ¢ ‚ûî ‚òÖ).
    Œ† alg: PrfAlg ¬∑P ‚ûî ‚àÄ Œì·µ¢. Œ† fr: F ¬∑Fix·µ¢ Œì·µ¢.
    { induction·µ¢ alg (in gr) ‚âÉ alg out·µ¢ (induction·µ¢ alg) fr}
  = Œª _. Œª _. Œ≤.
\end{verbatim}
That is, \verb;in·µ¢; and \verb;out·µ¢; are inverses of each other and
\verb;induction·µ¢; behaves like a fold (where the algebra takes the additional
\verb;out·µ¢; argument).

\subsection{Sum-of-Products Induction}
As stated above, every inductive data-type declaration
$\indast{I}{p}{Œì_I}{\Sigma}$ is first translated to a type-scheme \verb;IF;
where all recursive occurrences of type \verb;I; in the constructor signatures
$\Sigma$ have been replaced by the scheme's argument \verb;R;. In this
subsection describe that process more precisely and explain ``sum-of-products''
induction for \verb;IF;

First, as the kind of \verb;I; is \verb;Œ† Œì‚Çö. Œ† Œì·µ¢. ‚òÖ;, where \verb;Œì‚Çö; are the
parameters and \verb;Œì·µ¢; the indices, it follows that the kind of \verb;IF; is
\verb;Œ† Œì‚Çö. Œ† R: (Œ† Œì·µ¢. ‚òÖ). (Œ† Œì·µ¢. ‚òÖ);. Next, each constructor $c_j$ has type
$\Sigma(c_j)$ which we know has the form $\piforall\ \Gamma_j.\ I\ \Gamma_p\
\vars{t_j}$ (that is, some number of arguments $\Gamma_j$ with a return type
constructing the inductive data-type $I$). All recursive occurrences of $I$ in
$\Gamma_j$ are substituted away with \verb;Œª Œì‚Çö. R; to produce $Œì^R_j$. With
that, we may defined \verb;IF; as

\[ Œª\ Œì‚Çö\ \texttt{R}\ Œì·µ¢.\ ‚àÄ X: Œ†\ Œì·µ¢. ‚òÖ. (Œ†\ c_j: (\piforall Œì^R_j.\ X\
  \vars{t_j}))_{j=1..n}.\ X\ Œì·µ¢\]

\paragraph{Example}

The data-type declaration of \verb;Vec; translates to:
\begin{verbatim}
VecF : Œ† A: ‚òÖ. (Nat ‚ûî ‚òÖ) ‚ûî Nat ‚ûî ‚òÖ
  = Œª A R n. ‚àÄ X: Nat ‚ûî ‚òÖ. X zero ‚ûî (‚àÄ n: Nat. A ‚ûî R n ‚ûî X (succ n)) ‚ûî X n.
\end{verbatim}

An induction principle for each of these non-recursive sum-of-products types
\verb;IF; can be defined in an automated way following the recipe given by
[TODO]; in general these have the following shape:

\begin{verbatim}
indIF : ‚àÄ Œì‚Çö. ‚àÄ R: (Œ† Œì·µ¢. ‚òÖ). ‚àÄ Œì·µ¢. Œ† fr: IF Œì‚Çö ¬∑R Œì·µ¢. ‚àÄ P: (Œ† Œì·µ¢. IF Œì‚Çö ¬∑R Œì·µ¢ ‚ûî ‚òÖ)
    (Œ† p‚±º: Œ® Œì·¥ø‚±º. P (c‚±º Œì·¥ø‚±º))‚±º‚Çå‚ÇÅ‚ãØ‚Çô. P Œì·µ¢ fr = <..>
\end{verbatim}

\appendix
\section{Deriving \texttt{IdMapping·µ¢} for a Data-type Type Scheme}
A type scheme \verb;F; derived from a data-type declaration has by assumption a
definition following the pattern:

\begin{verbatim}
F : Œ† Œì‚Çö. (Œ† Œì·µ¢. ‚òÖ) ‚Üí Œ† Œì·µ¢. ‚òÖ
  = Œª Œì‚Çö R Œì·µ¢. ‚àÄ X: (Œ† Œì·µ¢. ‚òÖ). (Œ† c‚±º: (Œ® Œì·¥ø‚±º. X ‚Ç∏‚±º))‚±º‚Çå‚ÇÅ‚Çã‚Çô. X Œì·µ¢
\end{verbatim}

\noindent where \verb;R; occurs only positively. From this we must give a
witness that \verb;F; is an identity mapping over \verb;R;

\begin{verbatim}
idmap : ‚àÄ Œì‚Çö. IdMapping·µ¢ ¬∑(F Œì‚Çö)
  = Œõ Œì‚Çö. Œõ R1. Œõ R2. Œõ id. ‚óè
\end{verbatim}

\noindent where the expected type of \verb;‚óè; is \verb;Id·µ¢ ¬∑(F ¬∑Œì‚Çö R1) ¬∑(F ¬∑Œì R2);

We refine \verb;‚óè; by the introduction rule for intersections (which \verb;Id·µ¢; is) and
introduce the assumption \verb;fr1: F ¬∑Œì‚Çö R1 ¬∑Œì·µ¢;

\begin{verbatim}
[ Œõ Œì·µ¢. Œª fr1. ‚óè‚ÇÅ , ‚óè‚ÇÇ]
\end{verbatim}

\noindent where \verb;‚óè‚ÇÅ: F ¬∑Œì‚Çö R2 ¬∑Œì·µ¢; and \verb;‚óè‚ÇÇ: {Œª fr1. ‚óè‚ÇÅ ‚âÉ Œª x. x};. As
the only (non-hole) refinements we will make to \verb;‚óè‚ÇÅ; are converting terms to $\eta$-long
form and applying \verb;elimId·µ¢ -id; to subterms (which reduces to the identity
function), we are justified in replacing \verb;‚óè‚ÇÇ; with \verb;Œ≤;. We now refine
the remaining \verb;‚óè‚ÇÅ; to

\begin{verbatim}
Œõ X. Œª ≈ü. ‚óè fr1 ≈ü
\end{verbatim}

\noindent where each abstract constructor \texttt{c‚±º} in ≈ü has type
\verb;Œ® Œì·¥ø¬≤‚±º. X ‚Ç∏‚±º;. Note again the superscript \verb;R2; -- we are now trying
to construct a term of type \verb;F ¬∑Œì‚Çö R2 ¬∑Œì·µ¢; so we assume the ``abstract''
constructors whose recursive occurence types are \verb;R2;. Correspondingly,
this means that \verb;‚óè: F ¬∑Œì‚Çö R1 ¬∑Œì·µ¢ ‚Üí (Œ† c‚±º: (Œ® Œì·¥ø¬≤‚±º. X ‚Ç∏‚±º))‚±º‚Çå‚ÇÅ‚Çã‚Çô ‚Üí X Œì·µ¢;.

Since \verb;fr1; produces a value of type \verb;X Œì·µ¢; when fed appropriate
arguments, we refine \verb;‚óè; by $n$ holes \verb;‚óè‚±º; applied to constructor
\verb;c‚±º;. The expression \verb;‚óè fr1 ≈ü; becomes

\begin{verbatim}
fr1 (‚óè‚±º c‚±º)‚±º‚Çå‚ÇÅ‚Çã‚Çô
\end{verbatim}

\noindent where now \verb;‚óè‚±º: (Œ® Œì·¥ø¬≤‚±º. X ‚Ç∏‚±º) ‚Üí Œ® Œì·¥ø¬π‚±º. X ‚Ç∏‚±º;. We henceforth
dispense with the subscript $j$ numbering the constructor and treat each
abstract constructor uniformly.

\subsection{Conversion of the Abstract constructors}
We first make the expression \verb;‚óè c; $\eta$-long, as in \verb;œà Œì·¥ø¬π. ‚óè c Œì·¥ø¬π;,
then refine \verb;‚óè c Œì·¥ø¬π; to an expression with $m$ holes \verb;‚óè‚Çñ; for each $\texttt{y}_k \in
Œì^{\texttt{R1}}$ (where $m\ =\ \lenc{Œì^{\texttt{R1}}}$), yielding

\begin{verbatim}
c (‚óè‚Çñ y‚Çñ)‚Çñ‚Çå‚ÇÅ‚Çã‚Çò
\end{verbatim}

\noindent where \verb;‚óè‚Çñ: Œì·¥ø¬π(y‚Çñ) ‚Üí Œì·¥ø¬≤‚Çñ(y‚Çñ); (and the type of \verb;y‚Çñ;
and \verb;‚óè‚Çñ y‚Çñ; can depend resp. on any \verb;y·¥ø¬π‚±º; and \verb;‚óè‚±º y‚±º; where
$j < k$). We now dispense with the subscript $k$ for arguments and handle each
constructor sub-data uniformly.

\subsection{Conversion of Constructor Sub-data With Positive Recursive Occurences}
\label{ssec:positive}
We now consider \verb;‚óè y; where \verb;y: S; is some sub-data to an
(abstract) constructor with recursive occurence type \verb;R1; passing the
positivity checker. (The expression \verb;‚óè y; has type \verb;[R2/R1]S;).
There are two cases to consider:

\begin{itemize}
\item[1] \verb;R1; does not occur in the type of \verb;y;

  Refine \verb;‚óè; to \verb;unit: ‚àÄ X: ‚òÖ. X ‚Üí X = Œõ X. Œª x. x; and finish.
\item[2] \verb;R1; occurs positively in the type of \verb;y;

  This means $S$ has the shape \verb;Œ® Œì·¥ø¬π‚Çì. T; (where \verb;T; is not formed by
  an arrow) with \verb;R1;
  occurring \textit{only negatively} in the type of the
  $\texttt{x‚±º} \in Œì^{R1}_x$ (where $j=1..\lenc{Œì^{R1}‚Çì}$). Make \verb;‚óè y;
  $\eta$-long and refine the expression to $\lenc{Œì^{R1}‚Çì}$ holes \verb;‚óè‚±º; such
  that the expression is now
  
\begin{verbatim}
œà Œì·¥ø¬≤‚Çì. ‚óè y (‚óè‚±º x‚±º)‚±º‚Çå‚ÇÅ‚Çã‚Çô
\end{verbatim}

  \noindent Where here \verb;x‚±º; is bound by \verb;Œì·¥ø¬≤; and thus has negative occurences
  of \verb;R2;. Note that we still require \verb;‚óè; since it might be the case that
  \verb;T = R1 Œì·µ¢; (handled below); it has type \verb;S ‚Üí Œ® Œì·¥ø¬π‚Çì. [R1/R2]T;.
  Each \verb;‚óè‚±º; has type \verb;Œì·¥ø¬≤‚Çì(x‚±º) ‚Üí Œì·¥ø¬π‚Çì(x‚±º);.

  Perform the steps outlined in Section \ref{ssec:negative} to fill in each
  \verb;‚óè‚±º; producing from \verb;‚óè‚±º x‚±º; the sequence of arguments \verb;‚Ç∏‚±º; of
  type \verb;Œì·¥ø¬π‚Çì; that erase to \verb;x‚±º‚Çå‚ÇÅ‚Çã‚Çô; Finally, refine \verb;‚óè; to either \verb;unit; or
  \verb;Œª y. Œª x‚±º. elimId -c (y x‚±º); depending on whether \verb;T = R1 Œì·µ¢;

\end{itemize}

\subsection{Conversion of Constructor Sub-data With Negative Recursive
  Occurences}
\label{ssec:negative}
We consider \verb;‚óè x; where \verb;x: Œ® Œì·¥ø¬≤·µ§. S;, \verb;S; is not an arrow
and does not contain \verb;R2;, and \verb;R2; occurs positively in the types of
the variables bound by \verb;Œì·¥ø¬≤·µ§;. The expression \verb;‚óè x; has type
\verb;Œ® Œì·¥ø¬π·µ§. S;.

Make \verb;‚óè x; $\eta$-long and introduce holes \verb;‚óè‚±º; to apply to the
sub-data as in

\begin{verbatim}
œà Œì·¥ø¬π·µ§. x (‚óè‚±º y‚±º)‚±º‚Çå‚ÇÅ‚Çã‚Çô
\end{verbatim}

\noindent where \verb;‚óè‚±º: Œì·¥ø¬π·µ§(y‚±º) ‚Üí Œì·¥ø¬≤·µ§(y‚±º);. Perform the steps outlined by
Section \ref{ssec:positive} to fill in each \verb;‚óè‚±º; producing from
\verb;‚óè‚±º y‚±º; the sequence of arguments \verb;‚Ç∏; that erase to \verb;y‚±º‚Çå‚ÇÅ‚Çã‚Çô;.


\bibliographystyle{alpha}
\bibliography{spec}

\end{document}
